.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "LaTeXML::MathParser 3"
.TH LaTeXML::MathParser 3 "2022-12-08" "perl v5.32.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"LaTeXML::MathParser" \- parses mathematics content
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`LaTeXML::MathParser\*(C'\fR parses the mathematical content of a document.
It uses Parse::RecDescent and a grammar \f(CW\*(C`MathGrammar\*(C'\fR.
.SS "Math Representation"
.IX Subsection "Math Representation"
Needs description.
.SS "Possibile Customizations"
.IX Subsection "Possibile Customizations"
Needs description.
.SS "Convenience functions"
.IX Subsection "Convenience functions"
The following functions are exported for convenience in writing the
grammar productions.
.ie n .IP """$node = New($name,$content,%attributes);""" 4
.el .IP "\f(CW$node = New($name,$content,%attributes);\fR" 4
.IX Item "$node = New($name,$content,%attributes);"
Creates a new \f(CW\*(C`XMTok\*(C'\fR node with given \f(CW$name\fR (a string or undef),
and \f(CW$content\fR (a string or undef) (but at least one of name or content should be provided),
and attributes.
.ie n .IP """$node = Arg($node,$n);""" 4
.el .IP "\f(CW$node = Arg($node,$n);\fR" 4
.IX Item "$node = Arg($node,$n);"
Returns the \f(CW$n\fR\-th argument of an \f(CW\*(C`XMApp\*(C'\fR node;
0 is the operator node.
.ie n .IP """Annotate($node,%attributes);""" 4
.el .IP "\f(CWAnnotate($node,%attributes);\fR" 4
.IX Item "Annotate($node,%attributes);"
Add attributes to \f(CW$node\fR.
.ie n .IP """$node = Apply($op,@args);""" 4
.el .IP "\f(CW$node = Apply($op,@args);\fR" 4
.IX Item "$node = Apply($op,@args);"
Create a new \f(CW\*(C`XMApp\*(C'\fR node representing the application of the node
\&\f(CW$op\fR to the nodes \f(CW@args\fR.
.ie n .IP """$node = ApplyDelimited($op,@stuff);""" 4
.el .IP "\f(CW$node = ApplyDelimited($op,@stuff);\fR" 4
.IX Item "$node = ApplyDelimited($op,@stuff);"
Create a new \f(CW\*(C`XMApp\*(C'\fR node representing the application of the node
\&\f(CW$op\fR to the arguments found in \f(CW@stuff\fR.  \f(CW@stuff\fR are
delimited arguments in the sense that the leading and trailing nodes
should represent open and close delimiters and the arguments are
separated by punctuation nodes.
.ie n .IP """$node = InterpretDelimited($op,@stuff);""" 4
.el .IP "\f(CW$node = InterpretDelimited($op,@stuff);\fR" 4
.IX Item "$node = InterpretDelimited($op,@stuff);"
Similar to \f(CW\*(C`ApplyDelimited\*(C'\fR, this interprets sequence of
delimited, punctuated items as being the application of \f(CW$op\fR to those items.
.ie n .IP """$node = recApply(@ops,$arg);""" 4
.el .IP "\f(CW$node = recApply(@ops,$arg);\fR" 4
.IX Item "$node = recApply(@ops,$arg);"
Given a sequence of operators and an argument, forms the nested
application \f(CW\*(C`op(op(...(arg)))\*(C'\fR>.
.ie n .IP """$node = InvisibleTimes;""" 4
.el .IP "\f(CW$node = InvisibleTimes;\fR" 4
.IX Item "$node = InvisibleTimes;"
Creates an invisible times operator.
.ie n .IP """$boole = isMatchingClose($open,$close);""" 4
.el .IP "\f(CW$boole = isMatchingClose($open,$close);\fR" 4
.IX Item "$boole = isMatchingClose($open,$close);"
Checks whether \f(CW$open\fR and \f(CW$close\fR form a `normal' pair of
delimiters, or if either is \*(L".\*(R".
.ie n .IP """$node = Fence(@stuff);""" 4
.el .IP "\f(CW$node = Fence(@stuff);\fR" 4
.IX Item "$node = Fence(@stuff);"
Given a delimited sequence of nodes, starting and ending with open/close delimiters,
and with intermediate nodes separated by punctuation or such, attempt to guess what
type of thing is represented such as a set, absolute value, interval, and so on.
.Sp
This would be a good candidate for customization!
.ie n .IP """$node = NewFormulae(@stuff);""" 4
.el .IP "\f(CW$node = NewFormulae(@stuff);\fR" 4
.IX Item "$node = NewFormulae(@stuff);"
Given a set of formulas, construct a \f(CW\*(C`Formulae\*(C'\fR application, if there are more than one,
else just return the first.
.ie n .IP """$node = NewList(@stuff);""" 4
.el .IP "\f(CW$node = NewList(@stuff);\fR" 4
.IX Item "$node = NewList(@stuff);"
Given a set of expressions, construct a \f(CW\*(C`list\*(C'\fR application, if there are more than one,
else just return the first.
.ie n .IP """$node = LeftRec($arg1,@more);""" 4
.el .IP "\f(CW$node = LeftRec($arg1,@more);\fR" 4
.IX Item "$node = LeftRec($arg1,@more);"
Given an expr followed by repeated (op expr), compose the left recursive tree.
For example \f(CW\*(C`a + b + c \- d\*(C'\fR would give \f(CW\*(C`(\- (+ a b c) d)\*(C'\fR>
.ie n .IP """MaybeFunction($token);""" 4
.el .IP "\f(CWMaybeFunction($token);\fR" 4
.IX Item "MaybeFunction($token);"
Note the possible use of \f(CW$token\fR as a function, which may cause incorrect parsing.
This is used to generate warning messages.
.SH "AUTHOR"
.IX Header "AUTHOR"
Bruce Miller <bruce.miller@nist.gov>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Public domain software, produced as part of work done by the
United States Government & not subject to copyright in the \s-1US.\s0
