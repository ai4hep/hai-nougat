.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "LaTeXML::Package 3"
.TH LaTeXML::Package 3 "2022-12-16" "perl v5.32.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"LaTeXML::Package" \- Support for package implementations and document customization.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This package defines and exports most of the procedures users will need
to customize or extend LaTeXML. The LaTeXML implementation of some package
might look something like the following, but see the
installed \f(CW\*(C`LaTeXML/Package\*(C'\fR directory for realistic examples.
.PP
.Vb 10
\&  package LaTeXML::Package::pool;  # to put new subs & variables in common pool
\&  use LaTeXML::Package;            # to load these definitions
\&  use strict;                      # good style
\&  use warnings;
\&  #
\&  # Load "anotherpackage"
\&  RequirePackage(\*(Aqanotherpackage\*(Aq);
\&  #
\&  # A simple macro, just like in TeX
\&  DefMacro(\*(Aq\ethesection\*(Aq, \*(Aq\ethechapter.\eroman{section}\*(Aq);
\&  #
\&  # A constructor defines how a control sequence generates XML:
\&  DefConstructor(\*(Aq\ethanks{}\*(Aq, "<ltx:thanks>#1</ltx:thanks>");
\&  #
\&  # And a simple environment ...
\&  DefEnvironment(\*(Aq{abstract}\*(Aq,\*(Aq<abstract>#body</abstract>\*(Aq);
\&  #
\&  # A math  symbol \eReal to stand for the Reals:
\&  DefMath(\*(Aq\eReal\*(Aq, "\ex{211D}", role=>\*(AqID\*(Aq);
\&  #
\&  # Or a semantic floor:
\&  DefMath(\*(Aq\efloor{}\*(Aq,\*(Aq\eleft\elfloor#1\eright\erfloor\*(Aq);
\&  #
\&  # More esoteric ...
\&  # Use a RelaxNG schema
\&  RelaxNGSchema("MySchema");
\&  # Or use a special DocType if you have to:
\&  # DocType("rootelement",
\&  #         "\-//Your Site//Your DocType",\*(Aqyour.dtd\*(Aq,
\&  #          prefix=>"http://whatever/");
\&  #
\&  # Allow sometag elements to be automatically closed if needed
\&  Tag(\*(Aqprefix:sometag\*(Aq, autoClose=>1);
\&  #
\&  # Don\*(Aqt forget this, so perl knows the package loaded.
\&  1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a large set of utilities and declarations that are useful
for writing `bindings': LaTeXML-specific implementations of a set of control
sequences such as would be defined in a LaTeX style or class file. They are also
useful for controlling and customization of LaTeXML's processing.
See the \*(L"See also\*(R" section, below, for additional lower-level modules imported & re-exported.
.PP
To a limited extent (and currently only when explicitly enabled), LaTeXML can process
the raw TeX code found in style files.  However, to preserve document structure
and semantics, as well as for efficiency, it is usually necessary to supply a
LaTeXML-specific `binding' for style and class files. For example, a binding
\&\f(CW\*(C`mypackage.sty.ltxml\*(C'\fR would encode LaTeXML-specific implementations of
all the control sequences in \f(CW\*(C`mypackage.sty\*(C'\fR so that \f(CW\*(C`\eusepackage{mypackage}\*(C'\fR would work.
Similarly for \f(CW\*(C`myclass.cls.ltxml\*(C'\fR.  Additionally, document-specific bindings can
be supplied: before processing a TeX source file, eg \f(CW\*(C`mydoc.tex\*(C'\fR, LaTeXML
will automatically include the definitions and settings in \f(CW\*(C`mydoc.latexml\*(C'\fR.
These \f(CW\*(C`.ltxml\*(C'\fR and \f(CW\*(C`.latexml\*(C'\fR files should be placed LaTeXML's searchpaths, where will
find them: either in the current directory or in a directory given to the \-\-path option,
or possibly added to the variable \s-1SEARCHPATHS\s0).
.PP
Since LaTeXML mimics TeX, a familiarity with TeX's processing model is critical.
LaTeXML models: catcodes and tokens
(See LaTeXML::Core::Token,  LaTeXML::Core::Tokens) which are extracted
from the plain source text characters by the LaTeXML::Core::Mouth;
\&\*(L"Macros\*(R", which are expanded within the LaTeXML::Core::Gullet;
and \*(L"Primitives\*(R", which are digested within the LaTeXML::Core::Stomach
to produce LaTeXML::Core::Box, LaTeXML::Core::List.
A key additional feature is the \*(L"Constructors\*(R":
when digested they generate a LaTeXML::Core::Whatsit which, upon absorption by
LaTeXML::Core::Document, inserts text or \s-1XML\s0 fragments in the final document tree.
.PP
\&\fINotation:\fR Many of the following forms take code references as arguments or options.
That is, either a reference to a defined sub, eg. \f(CW\*(C`\e&somesub\*(C'\fR, or an
anonymous function \f(CW\*(C`sub { ... }\*(C'\fR.  To document these cases, and the
arguments that are passed in each case, we'll use a notation like
\&\f(CW\*(C`\f(CIcode\f(CW($stomach,...)\*(C'\fR.
.SS "Control Sequences"
.IX Subsection "Control Sequences"
Many of the following forms define the behaviour of control sequences.
While in TeX you'll typically only define macros, LaTeXML is effectively redefining TeX itself,
so we define \*(L"Macros\*(R" as well as \*(L"Primitives\*(R", \*(L"Registers\*(R",
\&\*(L"Constructors\*(R" and \*(L"Environments\*(R".
These define the behaviour of these control sequences when processed during the various
phases of LaTeX's imitation of TeX's digestive tract.
.PP
\fIPrototypes\fR
.IX Subsection "Prototypes"
.PP
LaTeXML uses a more convenient method of specifying parameter patterns for
control sequences. The first argument to each of these defining forms
(\f(CW\*(C`DefMacro\*(C'\fR, \f(CW\*(C`DefPrimive\*(C'\fR, etc) is a \fIprototype\fR consisting of the control
sequence being defined along with the specification of parameters required by the control sequence.
Each parameter describes how to parse tokens following the control sequence into
arguments or how to delimit them.  To simplify coding and capture common idioms
in TeX/LaTeX programming, latexml's parameter specifications are more expressive
than TeX's  \f(CW\*(C`\edef\*(C'\fR or LaTeX's \f(CW\*(C`\enewcommand\*(C'\fR.  Examples of the prototypes for
familiar TeX or LaTeX control sequences are:
.PP
.Vb 3
\&   DefConstructor(\*(Aq\eusepackage[]{}\*(Aq,...
\&   DefPrimitive(\*(Aq\emultiply Variable SkipKeyword:by Number\*(Aq,..
\&   DefPrimitive(\*(Aq\enewcommand OptionalMatch:* DefToken[]{}\*(Aq, ...
.Ve
.PP
The general syntax for parameter specification is
.ie n .IP """{\fIspec\fP}""" 4
.el .IP "\f(CW{\f(CIspec\f(CW}\fR" 4
.IX Item "{spec}"
reads a regular TeX argument.
\&\fIspec\fR can be omitted (ie. \f(CW\*(C`{}\*(C'\fR).
Otherwise \fIspec\fR is itself a parameter specification and
the argument is reparsed to accordingly.
(\f(CW\*(C`{}\*(C'\fR is a shorthand for \f(CW\*(C`Plain\*(C'\fR.)
.ie n .IP """[\fIspec\fP]""" 4
.el .IP "\f(CW[\f(CIspec\f(CW]\fR" 4
.IX Item "[spec]"
reads an LaTeX-style optional argument.
\&\fIspec\fR can be omitted (ie. \f(CW\*(C`{}\*(C'\fR).
Otherwise, if \fIspec\fR is of the form Default:stuff, then stuff
would be the default value.
Otherwise \fIspec\fR is itself a parameter specification
and the argument, if supplied, is reparsed according to that specification.
(\f(CW\*(C`[]\*(C'\fR is a shorthand for \f(CW\*(C`Optional\*(C'\fR.)
.IP "\fIType\fR" 4
.IX Item "Type"
Reads an argument of the given type, where either
Type has been declared, or there exists a ReadType
function accessible from LaTeXML::Package::Pool.
See the available types, below.
.ie n .IP """\fIType\fP:\fIvalue\fP | \fIType\fP:\fIvalue1\fP:\fIvalue2\fP...""" 4
.el .IP "\f(CW\f(CIType\f(CW:\f(CIvalue\f(CW | \f(CIType\f(CW:\f(CIvalue1\f(CW:\f(CIvalue2\f(CW...\fR" 4
.IX Item "Type:value | Type:value1:value2..."
These forms invoke the parser for \fIType\fR but
pass additional Tokens to the reader function.
Typically this would supply defaults or parameters to a match.
.ie n .IP """Optional\fIType\fP""" 4
.el .IP "\f(CWOptional\f(CIType\f(CW\fR" 4
.IX Item "OptionalType"
Similar to \fIType\fR, but it is not considered
an error if the reader returns undef.
.ie n .IP """Skip\fIType\fP""" 4
.el .IP "\f(CWSkip\f(CIType\f(CW\fR" 4
.IX Item "SkipType"
Similar to \f(CW\*(C`Optional\*(C'\fR\fIType\fR, but the value returned
from the reader is ignored, and does not occupy a
position in the arguments list.
.PP
The predefined argument \fIType\fRs are as follows.
.ie n .IP """Plain, Semiverbatim""" 4
.el .IP "\f(CWPlain, Semiverbatim\fR" 4
.IX Item "Plain, Semiverbatim"

Reads a standard TeX argument being either the next token, or if the
next token is an {, the balanced token list.  In the case of \f(CW\*(C`Semiverbatim\*(C'\fR,
many catcodes are disabled, which is handy for \s-1URL\s0's, labels and similar.
.IX Xref "Plain Semiverbatim"
.ie n .IP """Token, XToken""" 4
.el .IP "\f(CWToken, XToken\fR" 4
.IX Item "Token, XToken"

Read a single TeX Token.  For \f(CW\*(C`XToken\*(C'\fR, if the next token is expandable,
it is repeatedly expanded until an unexpandable token remains, which is returned.
.IX Xref "Token XToken"
.ie n .IP """Number, Dimension, Glue | MuGlue""" 4
.el .IP "\f(CWNumber, Dimension, Glue | MuGlue\fR" 4
.IX Item "Number, Dimension, Glue | MuGlue"

Read an Object corresponding to Number, Dimension, Glue or MuGlue,
using TeX's rules for parsing these objects.
.IX Xref "Number Dimension Glue MuGlue"
.ie n .IP """Until:\fImatch\fP | XUntil:""\fImatch\fR>" 4
.el .IP "\f(CWUntil:\f(CImatch\f(CW | XUntil:\fR\fImatch\fR>" 4
.IX Item "Until:match | XUntil:match>"

Reads tokens until a match to the tokens \fImatch\fR is found, returning
the tokens preceding the match. This corresponds to TeX delimited arguments.
For \f(CW\*(C`XUntil\*(C'\fR, tokens are expanded as they are matched and accumulated
(but a brace reads and accumulates till a matching close brace, without expanding).
.IX Xref "Until XUntil"
.ie n .IP """UntilBrace""" 4
.el .IP "\f(CWUntilBrace\fR" 4
.IX Item "UntilBrace"

Reads tokens until the next open brace \f(CW\*(C`{\*(C'\fR.
This corresponds to the peculiar TeX construct \f(CW\*(C`\edef\efoo#{...\*(C'\fR.
.IX Xref "UntilBrace"
.ie n .IP """Match:\fImatch(|match)*\fP | Keyword:""\fImatch(|match)*\fR>" 4
.el .IP "\f(CWMatch:\f(CImatch(|match)*\f(CW | Keyword:\fR\fImatch(|match)*\fR>" 4
.IX Item "Match:match(|match)* | Keyword:match(|match)*>"

Reads tokens expecting a match to one of the token lists \fImatch\fR,
returning the one that matches, or undef.
For \f(CW\*(C`Keyword\*(C'\fR, case and catcode of the \fImatches\fR are ignored.
Additionally, any leading spaces are skipped.
.IX Xref "Match Keyword"
.ie n .IP """Balanced""" 4
.el .IP "\f(CWBalanced\fR" 4
.IX Item "Balanced"

Read tokens until a closing }, but respecting nested {} pairs.
.IX Xref "Balanced"
.ie n .IP """BalancedParen""" 4
.el .IP "\f(CWBalancedParen\fR" 4
.IX Item "BalancedParen"

Read a parenthesis delimited tokens, but does \fInot\fR balance any nested parentheses.
.IX Xref "BalancedParen"
.ie n .IP """Undigested, Digested, DigestUntil:\fImatch\fP""" 4
.el .IP "\f(CWUndigested, Digested, DigestUntil:\f(CImatch\f(CW\fR" 4
.IX Item "Undigested, Digested, DigestUntil:match"

These types alter the usual sequence of tokenization and digestion in separate stages (like TeX).
A \f(CW\*(C`Undigested\*(C'\fR parameter inhibits digestion completely and remains in token form.
A \f(CW\*(C`Digested\*(C'\fR parameter gets digested until the (required) opening { is balanced; this is
useful when the content would usually need to have been protected in order to correctly deal
with catcodes.  \f(CW\*(C`DigestUntil\*(C'\fR digests tokens until a token matching \fImatch\fR is found.
.IX Xref "Undigested Digested"
.ie n .IP """Variable""" 4
.el .IP "\f(CWVariable\fR" 4
.IX Item "Variable"

Reads a token, expanding if necessary, and expects a control sequence naming
a writable register.  If such is found, it returns an array of the corresponding
definition object, and any arguments required by that definition.
.IX Xref "Variable"
.ie n .IP """SkipSpaces, Skip1Space""" 4
.el .IP "\f(CWSkipSpaces, Skip1Space\fR" 4
.IX Item "SkipSpaces, Skip1Space"

Skips one, or any number of, space tokens, if present, but contributes nothing to the argument list.
.IX Xref "SkipSpaces Skip1Space"
.PP
\fICommon Options\fR
.IX Subsection "Common Options"
.ie n .IP """scope=>\*(Aqlocal\*(Aq | \*(Aqglobal\*(Aq | \fIscope\fP""" 4
.el .IP "\f(CWscope=>\*(Aqlocal\*(Aq | \*(Aqglobal\*(Aq | \f(CIscope\f(CW\fR" 4
.IX Item "scope=>local | global | scope"
Most defining commands accept an option to control how the definition is stored,
for global or local definitions, or using a named \fIscope\fR
A named scope saves a set of definitions and values that can be activated at a later time.
.Sp
Particularly interesting forms of scope are those that get automatically activated
upon changes of counter and label.  For example, definitions that have
\&\f(CW\*(C`scope=>\*(Aqsection:1.1\*(Aq\*(C'\fR  will be activated when the section number is \*(L"1.1\*(R",
and will be deactivated when that section ends.
.ie n .IP """locked=>\fIboolean\fP""" 4
.el .IP "\f(CWlocked=>\f(CIboolean\f(CW\fR" 4
.IX Item "locked=>boolean"
This option controls whether this definition is locked from further
changes in the TeX sources; this keeps local 'customizations' by an author
from overriding important LaTeXML definitions and breaking the conversion.
.ie n .IP """protected=>\fIboolean\fP""" 4
.el .IP "\f(CWprotected=>\f(CIboolean\f(CW\fR" 4
.IX Item "protected=>boolean"
Makes a definition \*(L"protected\*(R", in the sense of eTeX's \f(CW\*(C`\eprotected\*(C'\fR directive.
This inhibits expansion under certain circumstances.
.ie n .IP """robust=>\fIboolean\fP""" 4
.el .IP "\f(CWrobust=>\f(CIboolean\f(CW\fR" 4
.IX Item "robust=>boolean"
Makes a definition \*(L"robust\*(R", in the sense of LaTeX's \f(CW\*(C`\eDeclareRobustCommand\*(C'\fR.
This essentially creates an indirect macro definition which is preceded by \f(CW\*(C`\eprotect\*(C'\fR.
This inhibits expansion (and argument processing!) under certain circumstances.
It usually only makes sense for macros, but may be useful for Primitives, Constructors
and DefMath in cases where LaTeX would normally have created a macro that needs protection.
.PP
\fIMacros\fR
.IX Subsection "Macros"
.ie n .IP """DefMacro(\fIprototype\fP, \fIexpansion\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefMacro(\f(CIprototype\f(CW, \f(CIexpansion\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefMacro(prototype, expansion, %options);"

Defines the macro expansion for \fIprototype\fR; a macro control sequence that is
expanded during macro expansion time in the  LaTeXML::Core::Gullet.
The \fIexpansion\fR should be one of \fItokens\fR | \fIstring\fR | \fIcode\fR($gullet,@args)>:
a \fIstring\fR will be tokenized upon first usage.
Any macro arguments will be substituted for parameter indicators (eg #1)
in the \fItokens\fR or tokenized \fIstring\fR and the result is used as the expansion
of the control sequence. If \fIcode\fR is used, it is called at expansion time
and should return a list of tokens as its result.
.IX Xref "DefMacro"
.Sp
DefMacro options are
.RS 4
.ie n .IP """scope=>\fIscope\fP""," 4
.el .IP "\f(CWscope=>\f(CIscope\f(CW\fR," 4
.IX Item "scope=>scope,"
.PD 0
.ie n .IP """locked=>\fIboolean\fP""" 4
.el .IP "\f(CWlocked=>\f(CIboolean\f(CW\fR" 4
.IX Item "locked=>boolean"
.PD
See \*(L"Common Options\*(R".
.ie n .IP """mathactive=>\fIboolean\fP""" 4
.el .IP "\f(CWmathactive=>\f(CIboolean\f(CW\fR" 4
.IX Item "mathactive=>boolean"
specifies a definition that will only be expanded in math mode;
the control sequence must be a single character.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 2
\&  DefMacro(\*(Aq\ethefootnote\*(Aq,\*(Aq\earabic{footnote}\*(Aq);
\&  DefMacro(\*(Aq\etoday\*(Aq,sub { ExplodeText(today()); });
.Ve
.RE
.ie n .IP """DefMacroI(\fIcs\fP, \fIparamlist\fP, \fIexpansion\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefMacroI(\f(CIcs\f(CW, \f(CIparamlist\f(CW, \f(CIexpansion\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefMacroI(cs, paramlist, expansion, %options);"

Internal form of \f(CW\*(C`DefMacro\*(C'\fR where the control sequence and parameter list
have already been separated; useful for definitions from within code.
Also, slightly more efficient for macros with no arguments (use \f(CW\*(C`undef\*(C'\fR for
\&\fIparamlist\fR), and useful for obscure cases like defining \f(CW\*(C`\ebegin{something*}\*(C'\fR
as a Macro.
.IX Xref "DefMacroI"
.PP
\fIConditionals\fR
.IX Subsection "Conditionals"
.ie n .IP """DefConditional(\fIprototype\fP, \fItest\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefConditional(\f(CIprototype\f(CW, \f(CItest\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefConditional(prototype, test, %options);"

Defines a conditional for \fIprototype\fR; a control sequence that is
processed during macro expansion time (in the  LaTeXML::Core::Gullet).
A conditional corresponds to a TeX \f(CW\*(C`\eif\*(C'\fR.
If the \fItest\fR is \f(CW\*(C`undef\*(C'\fR, a \f(CW\*(C`\enewif\*(C'\fR type of conditional is defined,
which is controlled with control sequences like \f(CW\*(C`\efootrue\*(C'\fR and \f(CW\*(C`\efoofalse\*(C'\fR.
Otherwise the \fItest\fR should be \f(CW\*(C`\f(CIcode\f(CW($gullet,@args)\*(C'\fR (with the control sequence's arguments)
that is called at expand time to determine the condition.
Depending on whether the result of that evaluation returns a true or false value
(in the usual Perl sense), the result of the expansion is either the
first or else code following, in the usual TeX sense.
.IX Xref "DefConditional"
.Sp
DefConditional options are
.RS 4
.ie n .IP """scope=>\fIscope\fP""," 4
.el .IP "\f(CWscope=>\f(CIscope\f(CW\fR," 4
.IX Item "scope=>scope,"
.PD 0
.ie n .IP """locked=>\fIboolean\fP""" 4
.el .IP "\f(CWlocked=>\f(CIboolean\f(CW\fR" 4
.IX Item "locked=>boolean"
.PD
See \*(L"Common Options\*(R".
.ie n .IP """skipper=>\fIcode\fP($gullet)""" 4
.el .IP "\f(CWskipper=>\f(CIcode\f(CW($gullet)\fR" 4
.IX Item "skipper=>code($gullet)"
This option is \fIonly\fR used to define \f(CW\*(C`\eifcase\*(C'\fR.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 2
\&  DefConditional(\*(Aq\eifmmode\*(Aq,sub {
\&     LookupValue(\*(AqIN_MATH\*(Aq); });
.Ve
.RE
.ie n .IP """DefConditionalI(\fIcs\fP, \fIparamlist\fP, \fItest\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefConditionalI(\f(CIcs\f(CW, \f(CIparamlist\f(CW, \f(CItest\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefConditionalI(cs, paramlist, test, %options);"

Internal form of \f(CW\*(C`DefConditional\*(C'\fR where the control sequence and parameter list
have already been parsed; useful for definitions from within code.
Also, slightly more efficient for conditinal with no arguments (use \f(CW\*(C`undef\*(C'\fR for
\&\f(CW\*(C`paramlist\*(C'\fR).
.IX Xref "DefConditionalI"
.ie n .IP """IfCondition(\fI$ifcs\fP,\fI@args\fP)""" 4
.el .IP "\f(CWIfCondition(\f(CI$ifcs\f(CW,\f(CI@args\f(CW)\fR" 4
.IX Item "IfCondition($ifcs,@args)"

\&\f(CW\*(C`IfCondition\*(C'\fR allows you to test a conditional from within perl. Thus something like
\&\f(CW\*(C`if(IfCondition(\*(Aq\eifmmode\*(Aq)){ domath } else { dotext }\*(C'\fR might be equivalent to
TeX's \f(CW\*(C`\eifmmode domath \eelse dotext \efi\*(C'\fR.
.IX Xref "IfCondition"
.PP
\fIPrimitives\fR
.IX Subsection "Primitives"
.ie n .IP """DefPrimitive(\fIprototype\fP, \fIreplacement\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefPrimitive(\f(CIprototype\f(CW, \f(CIreplacement\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefPrimitive(prototype, replacement, %options);"

Defines a primitive control sequence; a primitive is processed during
digestion (in the  LaTeXML::Core::Stomach), after macro expansion but before Construction time.
Primitive control sequences generate Boxes or Lists, generally
containing basic Unicode content, rather than structured \s-1XML.\s0
Primitive control sequences are also executed for side effect during digestion,
effecting changes to the LaTeXML::Core::State.
.IX Xref "DefPrimitive"
.Sp
The \fIreplacement\fR can be a string used as the text content of a Box to be
created (using the current font).
Alternatively \fIreplacement\fR can be \f(CW\*(C`\f(CIcode\f(CW($stomach,@args)\*(C'\fR
(with the control sequence's arguments)
which is invoked at digestion time, probably for side-effect,
but returning Boxes or Lists or nothing.
\&\fIreplacement\fR may also be undef, which contributes nothing to the document,
but does record the TeX code that created it.
.Sp
DefPrimitive options are
.RS 4
.ie n .IP """scope=>\fIscope\fP""," 4
.el .IP "\f(CWscope=>\f(CIscope\f(CW\fR," 4
.IX Item "scope=>scope,"
.PD 0
.ie n .IP """locked=>\fIboolean\fP""" 4
.el .IP "\f(CWlocked=>\f(CIboolean\f(CW\fR" 4
.IX Item "locked=>boolean"
.PD
See \*(L"Common Options\*(R".
.ie n .IP """mode=> (\*(Aqtext\*(Aq | \*(Aqdisplay_math\*(Aq | \*(Aqinline_math\*(Aq)""" 4
.el .IP "\f(CWmode=> (\*(Aqtext\*(Aq | \*(Aqdisplay_math\*(Aq | \*(Aqinline_math\*(Aq)\fR" 4
.IX Item "mode=> (text | display_math | inline_math)"
Changes to this mode during digestion.
.ie n .IP """font=>{\fI%fontspec\fP}""" 4
.el .IP "\f(CWfont=>{\f(CI%fontspec\f(CW}\fR" 4
.IX Item "font=>{%fontspec}"
Specifies the font to use (see \*(L"Fonts\*(R").
If the font change is to only apply to material generated within this command,
you would also use \f(CW\*(C`<bounded=\*(C'\fR1>>; otherwise, the font will remain in effect afterwards
as for a font switching command.
.ie n .IP """bounded=>\fIboolean\fP""" 4
.el .IP "\f(CWbounded=>\f(CIboolean\f(CW\fR" 4
.IX Item "bounded=>boolean"
If true, TeX grouping (ie. \f(CW\*(C`{}\*(C'\fR) is enforced around this invocation.
.ie n .IP """requireMath=>\fIboolean\fP""," 4
.el .IP "\f(CWrequireMath=>\f(CIboolean\f(CW\fR," 4
.IX Item "requireMath=>boolean,"
.PD 0
.ie n .IP """forbidMath=>\fIboolean\fP""" 4
.el .IP "\f(CWforbidMath=>\f(CIboolean\f(CW\fR" 4
.IX Item "forbidMath=>boolean"
.PD
specifies whether the given constructor can \fIonly\fR appear,
or \fIcannot\fR appear, in math mode.
.ie n .IP """beforeDigest=>\fIcode\fP($stomach)""" 4
.el .IP "\f(CWbeforeDigest=>\f(CIcode\f(CW($stomach)\fR" 4
.IX Item "beforeDigest=>code($stomach)"
supplies a hook to execute during digestion
just before the main part of the primitive is executed
(and before any arguments have been read).
The \fIcode\fR should either return nothing (return;)
or a list of digested items (Box's,List,Whatsit).
It can thus change the State and/or add to the digested output.
.ie n .IP """afterDigest=>\fIcode\fP($stomach)""" 4
.el .IP "\f(CWafterDigest=>\f(CIcode\f(CW($stomach)\fR" 4
.IX Item "afterDigest=>code($stomach)"
supplies a hook to execute during digestion
just after the main part of the primitive ie executed.
it should either return nothing (return;) or digested items.
It can thus change the State and/or add to the digested output.
.ie n .IP """isPrefix=>\fIboolean\fP""" 4
.el .IP "\f(CWisPrefix=>\f(CIboolean\f(CW\fR" 4
.IX Item "isPrefix=>boolean"
indicates whether this is a prefix type of command;
This is only used for the special TeX assignment prefixes, like \f(CW\*(C`\eglobal\*(C'\fR.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&   DefPrimitive(\*(Aq\ebegingroup\*(Aq,sub { $_[0]\->begingroup; });
.Ve
.RE
.ie n .IP """DefPrimitiveI(\fIcs\fP, \fIparamlist\fP, \fIcode\fP($stomach,@args), \fI%options\fP);""" 4
.el .IP "\f(CWDefPrimitiveI(\f(CIcs\f(CW, \f(CIparamlist\f(CW, \f(CIcode\f(CW($stomach,@args), \f(CI%options\f(CW);\fR" 4
.IX Item "DefPrimitiveI(cs, paramlist, code($stomach,@args), %options);"

Internal form of \f(CW\*(C`DefPrimitive\*(C'\fR where the control sequence and parameter list
have already been separated; useful for definitions from within code.
.IX Xref "DefPrimitiveI"
.PP
\fIRegisters\fR
.IX Subsection "Registers"
.ie n .IP """DefRegister(\fIprototype\fP, \fIvalue\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefRegister(\f(CIprototype\f(CW, \f(CIvalue\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefRegister(prototype, value, %options);"

Defines a register with \fIvalue\fR as the initial value (a Number, Dimension, Glue, MuGlue or Tokens
\&\-\-\- I haven't handled Box's yet).  Usually, the \fIprototype\fR is just the control sequence,
but registers are also handled by prototypes like \f(CW\*(C`\ecount{Number}\*(C'\fR. \f(CW\*(C`DefRegister\*(C'\fR arranges
that the register value can be accessed when a numeric, dimension, ... value is being read,
and also defines the control sequence for assignment.
.IX Xref "DefRegister"
.Sp
Options are
.RS 4
.ie n .IP """readonly=>\fIboolean\fP""" 4
.el .IP "\f(CWreadonly=>\f(CIboolean\f(CW\fR" 4
.IX Item "readonly=>boolean"
specifies if it is not allowed to change this value.
.ie n .IP """getter=>\fIcode\fP(@args)""," 4
.el .IP "\f(CWgetter=>\f(CIcode\f(CW(@args)\fR," 4
.IX Item "getter=>code(@args),"
.PD 0
.ie n .IP """setter=>\fIcode\fP($value,@args)""" 4
.el .IP "\f(CWsetter=>\f(CIcode\f(CW($value,@args)\fR" 4
.IX Item "setter=>code($value,@args)"
.PD
By default \fIvalue\fR is stored in the State's Value table under a name concatenating the
control sequence and argument values.  These options allow other means of fetching and
storing the value.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&  DefRegister(\*(Aq\epretolerance\*(Aq,Number(100));
.Ve
.RE
.ie n .IP """DefRegisterI(\fIcs\fP, \fIparamlist\fP, \fIvalue\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefRegisterI(\f(CIcs\f(CW, \f(CIparamlist\f(CW, \f(CIvalue\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefRegisterI(cs, paramlist, value, %options);"

Internal form of \f(CW\*(C`DefRegister\*(C'\fR where the control sequence and parameter list
have already been parsed; useful for definitions from within code.
.IX Xref "DefRegisterI"
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.ie n .IP """DefConstructor(\fIprototype\fP, \fI$replacement\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefConstructor(\f(CIprototype\f(CW, \f(CI$replacement\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefConstructor(prototype, $replacement, %options);"

The Constructor is where LaTeXML really starts getting interesting;
invoking the control sequence will generate an arbitrary \s-1XML\s0
fragment in the document tree.  More specifically: during digestion, the arguments
will be read and digested, creating a LaTeXML::Core::Whatsit to represent the object. During
absorption by the LaTeXML::Core::Document, the \f(CW\*(C`Whatsit\*(C'\fR will generate the \s-1XML\s0 fragment according
to \fIreplacement\fR. The \fIreplacement\fR can be \f(CW\*(C`\f(CIcode\f(CW($document,@args,%properties)\*(C'\fR
which is called during document absorption to create the appropriate \s-1XML\s0
(See the methods of LaTeXML::Core::Document).
.IX Xref "DefConstructor"
.Sp
More conveniently, \fIreplacement\fR can be an pattern: simply a bit of \s-1XML\s0 as a string
with certain substitutions to be made. The substitutions are of the following forms:
.RS 4
.ie n .IP """#1, #2 ... #name""" 4
.el .IP "\f(CW#1, #2 ... #name\fR" 4
.IX Item "#1, #2 ... #name"
These are replaced by the corresponding argument (for #1) or property (for #name)
stored with the Whatsit. Each are turned into a string when it appears as
in an attribute position, or recursively processed when it appears as content.
.ie n .IP """&\fIfunction\fP(@args)""" 4
.el .IP "\f(CW&\f(CIfunction\f(CW(@args)\fR" 4
.IX Item "&function(@args)"
Another form of substituted value is prefixed with \f(CW\*(C`&\*(C'\fR which invokes a function.
For example, \f(CW\*(C` &func(#1) \*(C'\fR would invoke the function \f(CW\*(C`func\*(C'\fR on the first argument
to the control sequence; what it returns will be inserted into the document.
.ie n .IP """?\fItest\fP(\fIpattern\fP)""  or ""?\fItest\fP(\fIifpattern\fP)(\fIelsepattern\fP)""" 4
.el .IP "\f(CW?\f(CItest\f(CW(\f(CIpattern\f(CW)\fR  or \f(CW?\f(CItest\f(CW(\f(CIifpattern\f(CW)(\f(CIelsepattern\f(CW)\fR" 4
.IX Item "?test(pattern) or ?test(ifpattern)(elsepattern)"
Patterns can be conditionallized using this form.  The \fItest\fR is any
of the above expressions (eg. \f(CW\*(C`#1\*(C'\fR), considered true if the result is non-empty.
Thus \f(CW\*(C`?#1(<foo/>)\*(C'\fR would add the empty element \f(CW\*(C`foo\*(C'\fR if the first argument
were given.
.ie n .IP """^""" 4
.el .IP "\f(CW^\fR" 4
.IX Item "^"
If the constructor \fIbegins\fR with \f(CW\*(C`^\*(C'\fR, the \s-1XML\s0 fragment is allowed to \fIfloat up\fR
to a parent node that is allowed to contain it, according to the Document Type.
.RE
.RS 4
.Sp
The Whatsit property \f(CW\*(C`font\*(C'\fR is defined by default.  Additional properties
\&\f(CW\*(C`body\*(C'\fR and \f(CW\*(C`trailer\*(C'\fR are defined when \f(CW\*(C`captureBody\*(C'\fR is true, or for environments.
By using \f(CW\*(C`$whatsit\->setProperty(key=>$value);\*(C'\fR within \f(CW\*(C`afterDigest\*(C'\fR,
or by using the \f(CW\*(C`properties\*(C'\fR option, other properties can be added.
.Sp
DefConstructor options are
.ie n .IP """scope=>\fIscope\fP""," 4
.el .IP "\f(CWscope=>\f(CIscope\f(CW\fR," 4
.IX Item "scope=>scope,"
.PD 0
.ie n .IP """locked=>\fIboolean\fP""" 4
.el .IP "\f(CWlocked=>\f(CIboolean\f(CW\fR" 4
.IX Item "locked=>boolean"
.PD
See \*(L"Common Options\*(R".
.ie n .IP """mode=>\fImode\fP""," 4
.el .IP "\f(CWmode=>\f(CImode\f(CW\fR," 4
.IX Item "mode=>mode,"
.PD 0
.ie n .IP """font=>{\fI%fontspec\fP}""," 4
.el .IP "\f(CWfont=>{\f(CI%fontspec\f(CW}\fR," 4
.IX Item "font=>{%fontspec},"
.ie n .IP """bounded=>\fIboolean\fP""," 4
.el .IP "\f(CWbounded=>\f(CIboolean\f(CW\fR," 4
.IX Item "bounded=>boolean,"
.ie n .IP """requireMath=>\fIboolean\fP""," 4
.el .IP "\f(CWrequireMath=>\f(CIboolean\f(CW\fR," 4
.IX Item "requireMath=>boolean,"
.ie n .IP """forbidMath=>\fIboolean\fP""" 4
.el .IP "\f(CWforbidMath=>\f(CIboolean\f(CW\fR" 4
.IX Item "forbidMath=>boolean"
.PD
These options are the same as for \*(L"Primitives\*(R"
.ie n .IP """reversion=>\fItexstring\fP | \fIcode\fP($whatsit,#1,#2,...)""" 4
.el .IP "\f(CWreversion=>\f(CItexstring\f(CW | \f(CIcode\f(CW($whatsit,#1,#2,...)\fR" 4
.IX Item "reversion=>texstring | code($whatsit,#1,#2,...)"
specifies the reversion of the invocation back into TeX tokens
(if the default reversion is not appropriate).
The \fItextstring\fR string can include \f(CW\*(C`#1\*(C'\fR, \f(CW\*(C`#2\*(C'\fR...
The \fIcode\fR is called with the \f(CW$whatsit\fR and digested arguments
and must return a list of Token's.
.ie n .IP """alias=>\fIcontrol_sequence\fP""" 4
.el .IP "\f(CWalias=>\f(CIcontrol_sequence\f(CW\fR" 4
.IX Item "alias=>control_sequence"
provides a control sequence to be used in the \f(CW\*(C`reversion\*(C'\fR instead of
the one defined in the \f(CW\*(C`prototype\*(C'\fR.  This is a convenient alternative for
reversion when a 'public' command conditionally expands into
an internal one, but the reversion should be for the public command.
.ie n .IP """sizer=>\fIstring\fP | \fIcode\fP($whatsit)""" 4
.el .IP "\f(CWsizer=>\f(CIstring\f(CW | \f(CIcode\f(CW($whatsit)\fR" 4
.IX Item "sizer=>string | code($whatsit)"
specifies how to compute (approximate) the displayed size of the object,
if that size is ever needed (typically needed for graphics generation).
If a string is given, it should contain only a sequence of \f(CW\*(C`#1\*(C'\fR or \f(CW\*(C`#name\*(C'\fR to
access arguments and properties of the Whatsit: the size is computed from these
items layed out side-by-side.  If \fIcode\fR is given, it should return
the three Dimensions (width, height and depth).  If neither is given,
and the \f(CW\*(C`reversion\*(C'\fR specification is of suitible format, it will be used for the sizer.
.ie n .IP """properties=>{\fI%properties\fP} | \fIcode\fP($stomach,#1,#2...)""" 4
.el .IP "\f(CWproperties=>{\f(CI%properties\f(CW} | \f(CIcode\f(CW($stomach,#1,#2...)\fR" 4
.IX Item "properties=>{%properties} | code($stomach,#1,#2...)"
supplies additional properties to be set on the
generated Whatsit.  In the first form, the values can
be of any type, but if a value is a code references, it takes
the same args ($stomach,#1,#2,...) and should return the value;
it is executed before creating the Whatsit.
In the second form, the code should return a hash of properties.
.ie n .IP """beforeDigest=>\fIcode\fP($stomach)""" 4
.el .IP "\f(CWbeforeDigest=>\f(CIcode\f(CW($stomach)\fR" 4
.IX Item "beforeDigest=>code($stomach)"
supplies a hook to execute during digestion
just before the Whatsit is created.  The \fIcode\fR should either
return nothing (return;) or a list of digested items (Box's,List,Whatsit).
It can thus change the State and/or add to the digested output.
.ie n .IP """afterDigest=>\fIcode\fP($stomach,$whatsit)""" 4
.el .IP "\f(CWafterDigest=>\f(CIcode\f(CW($stomach,$whatsit)\fR" 4
.IX Item "afterDigest=>code($stomach,$whatsit)"
supplies a hook to execute during digestion
just after the Whatsit is created (and so the Whatsit already
has its arguments and properties). It should either return
nothing (return;) or digested items.  It can thus change the State,
modify the Whatsit, and/or add to the digested output.
.ie n .IP """beforeConstruct=>\fIcode\fP($document,$whatsit)""" 4
.el .IP "\f(CWbeforeConstruct=>\f(CIcode\f(CW($document,$whatsit)\fR" 4
.IX Item "beforeConstruct=>code($document,$whatsit)"
supplies a hook to execute before constructing the \s-1XML\s0
(generated by \fIreplacement\fR).
.ie n .IP """afterConstruct=>\fIcode\fP($document,$whatsit)""" 4
.el .IP "\f(CWafterConstruct=>\f(CIcode\f(CW($document,$whatsit)\fR" 4
.IX Item "afterConstruct=>code($document,$whatsit)"
Supplies \fIcode\fR to execute after constructing the \s-1XML.\s0
.ie n .IP """captureBody=>\fIboolean\fP | \fIToken\fP""" 4
.el .IP "\f(CWcaptureBody=>\f(CIboolean\f(CW | \f(CIToken\f(CW\fR" 4
.IX Item "captureBody=>boolean | Token"
if true, arbitrary following material will be accumulated into
a `body' until the current grouping level is reverted,
or till the \f(CW\*(C`Token\*(C'\fR is encountered if the option is a \f(CW\*(C`Token\*(C'\fR.
This body is available as the \f(CW\*(C`body\*(C'\fR property of the Whatsit.
This is used by environments and math.
.ie n .IP """nargs=>\fInargs\fP""" 4
.el .IP "\f(CWnargs=>\f(CInargs\f(CW\fR" 4
.IX Item "nargs=>nargs"
This gives a number of args for cases where it can't be inferred directly
from the \fIprototype\fR (eg. when more args are explicitly read by hooks).
.RE
.RS 4
.RE
.ie n .IP """DefConstructorI(\fIcs\fP, \fIparamlist\fP, \fIreplacement\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefConstructorI(\f(CIcs\f(CW, \f(CIparamlist\f(CW, \f(CIreplacement\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefConstructorI(cs, paramlist, replacement, %options);"

Internal form of \f(CW\*(C`DefConstructor\*(C'\fR where the control sequence and parameter list
have already been separated; useful for definitions from within code.
.IX Xref "DefConstructorI"
.ie n .IP """DefMath(\fIprototype\fP, \fItex\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefMath(\f(CIprototype\f(CW, \f(CItex\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefMath(prototype, tex, %options);"

A common shorthand constructor; it defines a control sequence that creates a mathematical object,
such as a symbol, function or operator application.
The options given can effectively create semantic macros that contribute to the eventual
parsing of mathematical content.
In particular, it generates an XMDual using the replacement \fItex\fR for the presentation.
The content information is drawn from the name and options
.IX Xref "DefMath"
.Sp
\&\f(CW\*(C`DefMath\*(C'\fR accepts the options:
.RS 4
.ie n .IP """scope=>\fIscope\fP""," 4
.el .IP "\f(CWscope=>\f(CIscope\f(CW\fR," 4
.IX Item "scope=>scope,"
.PD 0
.ie n .IP """locked=>\fIboolean\fP""" 4
.el .IP "\f(CWlocked=>\f(CIboolean\f(CW\fR" 4
.IX Item "locked=>boolean"
.PD
See \*(L"Common Options\*(R".
.ie n .IP """font=>{\fI%fontspec\fP}""," 4
.el .IP "\f(CWfont=>{\f(CI%fontspec\f(CW}\fR," 4
.IX Item "font=>{%fontspec},"
.PD 0
.ie n .IP """reversion=>\fIreversion\fP""," 4
.el .IP "\f(CWreversion=>\f(CIreversion\f(CW\fR," 4
.IX Item "reversion=>reversion,"
.ie n .IP """alias=>\fIcs\fP""," 4
.el .IP "\f(CWalias=>\f(CIcs\f(CW\fR," 4
.IX Item "alias=>cs,"
.ie n .IP """sizer=>\fIsizer\fP""," 4
.el .IP "\f(CWsizer=>\f(CIsizer\f(CW\fR," 4
.IX Item "sizer=>sizer,"
.ie n .IP """properties=>\fIproperties\fP""," 4
.el .IP "\f(CWproperties=>\f(CIproperties\f(CW\fR," 4
.IX Item "properties=>properties,"
.ie n .IP """beforeDigest=>\fIcode\fP($stomach)""," 4
.el .IP "\f(CWbeforeDigest=>\f(CIcode\f(CW($stomach)\fR," 4
.IX Item "beforeDigest=>code($stomach),"
.ie n .IP """afterDigest=>\fIcode\fP($stomach,$whatsit)""," 4
.el .IP "\f(CWafterDigest=>\f(CIcode\f(CW($stomach,$whatsit)\fR," 4
.IX Item "afterDigest=>code($stomach,$whatsit),"
.PD
These options are the same as for \*(L"Constructors\*(R"
.ie n .IP """name=>\fIname\fP""" 4
.el .IP "\f(CWname=>\f(CIname\f(CW\fR" 4
.IX Item "name=>name"
gives a name attribute for the object
.ie n .IP """omcd=>\fIcdname\fP""" 4
.el .IP "\f(CWomcd=>\f(CIcdname\f(CW\fR" 4
.IX Item "omcd=>cdname"
gives the OpenMath content dictionary that name is from.
.ie n .IP """role=>\fIgrammatical_role\fP""" 4
.el .IP "\f(CWrole=>\f(CIgrammatical_role\f(CW\fR" 4
.IX Item "role=>grammatical_role"
adds a grammatical role attribute to the object; this specifies
the grammatical role that the object plays in surrounding expressions.
This direly needs documentation!
.ie n .IP """mathstyle=>(\*(Aqdisplay\*(Aq | \*(Aqtext\*(Aq | \*(Aqscript\*(Aq | \*(Aqscriptscript\*(Aq)""" 4
.el .IP "\f(CWmathstyle=>(\*(Aqdisplay\*(Aq | \*(Aqtext\*(Aq | \*(Aqscript\*(Aq | \*(Aqscriptscript\*(Aq)\fR" 4
.IX Item "mathstyle=>(display | text | script | scriptscript)"
Controls whether the this object will be presented in a specific
mathstyle, or according to the current setting of \f(CW\*(C`mathstyle\*(C'\fR.
.ie n .IP """scriptpos=>(\*(Aqmid\*(Aq | \*(Aqpost\*(Aq)""" 4
.el .IP "\f(CWscriptpos=>(\*(Aqmid\*(Aq | \*(Aqpost\*(Aq)\fR" 4
.IX Item "scriptpos=>(mid | post)"
Controls the positioning of any sub and super-scripts relative to this object;
whether they be stacked over or under it, or whether they will appear in the usual position.
TeX.pool defines a function \f(CW\*(C`doScriptpos()\*(C'\fR which is useful for operators
like \f(CW\*(C`\esum\*(C'\fR in that it sets to \f(CW\*(C`mid\*(C'\fR position when in displaystyle, otherwise \f(CW\*(C`post\*(C'\fR.
.ie n .IP """stretchy=>\fIboolean\fP""" 4
.el .IP "\f(CWstretchy=>\f(CIboolean\f(CW\fR" 4
.IX Item "stretchy=>boolean"
Whether or not the object is stretchy when displayed.
.ie n .IP """operator_role=>\fIgrammatical_role\fP""," 4
.el .IP "\f(CWoperator_role=>\f(CIgrammatical_role\f(CW\fR," 4
.IX Item "operator_role=>grammatical_role,"
.PD 0
.ie n .IP """operator_scriptpos=>\fIboolean\fP""," 4
.el .IP "\f(CWoperator_scriptpos=>\f(CIboolean\f(CW\fR," 4
.IX Item "operator_scriptpos=>boolean,"
.ie n .IP """operator_stretchy=>\fIboolean\fP""" 4
.el .IP "\f(CWoperator_stretchy=>\f(CIboolean\f(CW\fR" 4
.IX Item "operator_stretchy=>boolean"
.PD
These three are similar to \f(CW\*(C`role\*(C'\fR, \f(CW\*(C`scriptpos\*(C'\fR and \f(CW\*(C`stretchy\*(C'\fR, but are used in
unusual cases.  These apply to the given attributes to the operator token
in the content branch.
.ie n .IP """nogroup=>\fIboolean\fP""" 4
.el .IP "\f(CWnogroup=>\f(CIboolean\f(CW\fR" 4
.IX Item "nogroup=>boolean"
Normally, these commands are digested with an implicit grouping around them,
localizing changes to fonts, etc; \f(CW\*(C`noggroup=>1\*(C'\fR inhibits this.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 2
\&  DefMath(\*(Aq\einfty\*(Aq,"\ex{221E}",
\&     role=>\*(AqID\*(Aq, meaning=>\*(Aqinfinity\*(Aq);
.Ve
.RE
.ie n .IP """DefMathI(\fIcs\fP, \fIparamlist\fP, \fItex\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefMathI(\f(CIcs\f(CW, \f(CIparamlist\f(CW, \f(CItex\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefMathI(cs, paramlist, tex, %options);"

Internal form of \f(CW\*(C`DefMath\*(C'\fR where the control sequence and parameter list
have already been separated; useful for definitions from within code.
.IX Xref "DefMathI"
.PP
\fIEnvironments\fR
.IX Subsection "Environments"
.ie n .IP """DefEnvironment(\fIprototype\fP, \fIreplacement\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefEnvironment(\f(CIprototype\f(CW, \f(CIreplacement\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefEnvironment(prototype, replacement, %options);"

Defines an Environment that generates a specific \s-1XML\s0 fragment.  \f(CW\*(C`replacement\*(C'\fR is
of the same form as for DefConstructor, but will generally include reference to
the \f(CW\*(C`#body\*(C'\fR property. Upon encountering a \f(CW\*(C`\ebegin{env}\*(C'\fR:  the mode is switched, if needed,
else a new group is opened; then the environment name is noted; the beforeDigest hook is run.
Then the Whatsit representing the begin command (but ultimately the whole environment) is created
and the afterDigestBegin hook is run.
Next, the body will be digested and collected until the balancing \f(CW\*(C`\eend{env}\*(C'\fR.   Then,
any afterDigest hook is run, the environment is ended, finally the mode is ended or
the group is closed.  The body and \f(CW\*(C`\eend{env}\*(C'\fR whatsit are added to the \f(CW\*(C`\ebegin{env}\*(C'\fR's whatsit
as body and trailer, respectively.
.IX Xref "DefEnvironment"
.Sp
\&\f(CW\*(C`DefEnvironment\*(C'\fR takes the following options:
.RS 4
.ie n .IP """scope=>\fIscope\fP""," 4
.el .IP "\f(CWscope=>\f(CIscope\f(CW\fR," 4
.IX Item "scope=>scope,"
.PD 0
.ie n .IP """locked=>\fIboolean\fP""" 4
.el .IP "\f(CWlocked=>\f(CIboolean\f(CW\fR" 4
.IX Item "locked=>boolean"
.PD
See \*(L"Common Options\*(R".
.ie n .IP """mode=>\fImode\fP""," 4
.el .IP "\f(CWmode=>\f(CImode\f(CW\fR," 4
.IX Item "mode=>mode,"
.PD 0
.ie n .IP """font=>{\fI%fontspec\fP}""" 4
.el .IP "\f(CWfont=>{\f(CI%fontspec\f(CW}\fR" 4
.IX Item "font=>{%fontspec}"
.ie n .IP """requireMath=>\fIboolean\fP""," 4
.el .IP "\f(CWrequireMath=>\f(CIboolean\f(CW\fR," 4
.IX Item "requireMath=>boolean,"
.ie n .IP """forbidMath=>\fIboolean\fP""," 4
.el .IP "\f(CWforbidMath=>\f(CIboolean\f(CW\fR," 4
.IX Item "forbidMath=>boolean,"
.PD
These options are the same as for \*(L"Primitives\*(R"
.ie n .IP """reversion=>\fIreversion\fP""," 4
.el .IP "\f(CWreversion=>\f(CIreversion\f(CW\fR," 4
.IX Item "reversion=>reversion,"
.PD 0
.ie n .IP """alias=>\fIcs\fP""," 4
.el .IP "\f(CWalias=>\f(CIcs\f(CW\fR," 4
.IX Item "alias=>cs,"
.ie n .IP """sizer=>\fIsizer\fP""," 4
.el .IP "\f(CWsizer=>\f(CIsizer\f(CW\fR," 4
.IX Item "sizer=>sizer,"
.ie n .IP """properties=>\fIproperties\fP""," 4
.el .IP "\f(CWproperties=>\f(CIproperties\f(CW\fR," 4
.IX Item "properties=>properties,"
.ie n .IP """nargs=>\fInargs\fP""" 4
.el .IP "\f(CWnargs=>\f(CInargs\f(CW\fR" 4
.IX Item "nargs=>nargs"
.PD
These options are the same as for \*(L"Constructors\*(R"
.ie n .IP """beforeDigest=>\fIcode\fP($stomach)""" 4
.el .IP "\f(CWbeforeDigest=>\f(CIcode\f(CW($stomach)\fR" 4
.IX Item "beforeDigest=>code($stomach)"
This hook is similar to that for \f(CW\*(C`DefConstructor\*(C'\fR,
but it applies to the \f(CW\*(C`\ebegin{environment}\*(C'\fR control sequence.
.ie n .IP """afterDigestBegin=>\fIcode\fP($stomach,$whatsit)""" 4
.el .IP "\f(CWafterDigestBegin=>\f(CIcode\f(CW($stomach,$whatsit)\fR" 4
.IX Item "afterDigestBegin=>code($stomach,$whatsit)"
This hook is similar to \f(CW\*(C`DefConstructor\*(C'\fR's \f(CW\*(C`afterDigest\*(C'\fR
but it applies to the \f(CW\*(C`\ebegin{environment}\*(C'\fR control sequence.
The Whatsit is the one for the beginning control sequence,
but represents the environment as a whole.
Note that although the arguments and properties are present in
the Whatsit, the body of the environment is \fInot\fR yet available!
.ie n .IP """beforeDigestEnd=>\fIcode\fP($stomach)""" 4
.el .IP "\f(CWbeforeDigestEnd=>\f(CIcode\f(CW($stomach)\fR" 4
.IX Item "beforeDigestEnd=>code($stomach)"
This hook is similar to \f(CW\*(C`DefConstructor\*(C'\fR's \f(CW\*(C`beforeDigest\*(C'\fR
but it applies to the \f(CW\*(C`\eend{environment}\*(C'\fR control sequence.
.ie n .IP """afterDigest=>\fIcode\fP($stomach,$whatsit)""" 4
.el .IP "\f(CWafterDigest=>\f(CIcode\f(CW($stomach,$whatsit)\fR" 4
.IX Item "afterDigest=>code($stomach,$whatsit)"
This hook is similar to \f(CW\*(C`DefConstructor\*(C'\fR's \f(CW\*(C`afterDigest\*(C'\fR
but it applies to the \f(CW\*(C`\eend{environment}\*(C'\fR control sequence.
Note, however that the Whatsit is only for the ending control sequence,
\&\fInot\fR the Whatsit for the environment as a whole.
.ie n .IP """afterDigestBody=>\fIcode\fP($stomach,$whatsit)""" 4
.el .IP "\f(CWafterDigestBody=>\f(CIcode\f(CW($stomach,$whatsit)\fR" 4
.IX Item "afterDigestBody=>code($stomach,$whatsit)"
This option supplies a hook to be executed during digestion
after the ending control sequence has been digested (and all the 4
other digestion hook have executed) and after
the body of the environment has been obtained.
The Whatsit is the (useful) one representing the whole
environment, and it now does have the body and trailer available,
stored as a properties.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 2
\&  DefConstructor(\*(Aq\eemph{}\*(Aq,
\&     "<ltx:emph>#1</ltx:emph", mode=>\*(Aqtext\*(Aq);
.Ve
.RE
.ie n .IP """DefEnvironmentI(\fIname\fP, \fIparamlist\fP, \fIreplacement\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefEnvironmentI(\f(CIname\f(CW, \f(CIparamlist\f(CW, \f(CIreplacement\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefEnvironmentI(name, paramlist, replacement, %options);"

Internal form of \f(CW\*(C`DefEnvironment\*(C'\fR where the control sequence and parameter list
have already been separated; useful for definitions from within code.
.IX Xref "DefEnvironmentI"
.SS "Inputing Content and Definitions"
.IX Subsection "Inputing Content and Definitions"
.ie n .IP """FindFile(\fIname\fP, \fI%options\fP);""" 4
.el .IP "\f(CWFindFile(\f(CIname\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "FindFile(name, %options);"

Find an appropriate file with the given \fIname\fR in the current directories
in \f(CW\*(C`SEARCHPATHS\*(C'\fR.
If a file ending with \f(CW\*(C`.ltxml\*(C'\fR is found, it will be preferred.
.IX Xref "FindFile"
.Sp
Note that if the \f(CW\*(C`name\*(C'\fR starts with a recognized \fIprotocol\fR
(currently one of \f(CW\*(C`(literal|http|https|ftp)\*(C'\fR) followed by a colon,
the name is returned, as is, and no search for files is carried out.
.Sp
The options are:
.RS 4
.ie n .IP """type=>\fItype\fP""" 4
.el .IP "\f(CWtype=>\f(CItype\f(CW\fR" 4
.IX Item "type=>type"
specifies the file type.  If not set, it will search for
both \f(CW\*(C`\f(CIname\f(CW.tex\*(C'\fR and \fIname\fR.
.ie n .IP """noltxml=>1""" 4
.el .IP "\f(CWnoltxml=>1\fR" 4
.IX Item "noltxml=>1"
inhibits searching for a LaTeXML binding (\f(CW\*(C`\f(CIname\f(CW.\f(CItype\f(CW.ltxml\*(C'\fR)
to use instead of the file itself.
.ie n .IP """notex=>1""" 4
.el .IP "\f(CWnotex=>1\fR" 4
.IX Item "notex=>1"
inhibits searching for raw tex version of the file.
That is, it will \fIonly\fR search for the LaTeXML binding.
.RE
.RS 4
.RE
.ie n .IP """InputContent(\fIrequest\fP, \fI%options\fP);""" 4
.el .IP "\f(CWInputContent(\f(CIrequest\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "InputContent(request, %options);"

\&\f(CW\*(C`InputContent\*(C'\fR is used for cases when the file (or data)
is plain TeX material that is expected to contribute content
to the document (as opposed to pure definitions).
A Mouth is opened onto the file, and subsequent reading
and/or digestion will pull Tokens from that Mouth until it is
exhausted, or closed.
.IX Xref "InputContent"
.Sp
In some circumstances it may be useful to provide a string containing
the TeX material explicitly, rather than referencing a file.
In this case, the \f(CW\*(C`literal\*(C'\fR pseudo-protocal may be used:
.Sp
.Vb 1
\&  InputContent(\*(Aqliteral:\etextit{Hey}\*(Aq);
.Ve
.Sp
If a file named \f(CW\*(C`$request.latexml\*(C'\fR exists, it will be read
in as if it were a latexml binding file, before processing.
This can be used for adhoc customization of the conversion of specific files,
without modifying the source, or creating more elaborate bindings.
.Sp
The only option to \f(CW\*(C`InputContent\*(C'\fR is:
.RS 4
.ie n .IP """noerror=>\fIboolean\fP""" 4
.el .IP "\f(CWnoerror=>\f(CIboolean\f(CW\fR" 4
.IX Item "noerror=>boolean"
Inhibits signalling an error if no appropriate file is found.
.RE
.RS 4
.RE
.ie n .IP """Input(\fIrequest\fP);""" 4
.el .IP "\f(CWInput(\f(CIrequest\f(CW);\fR" 4
.IX Item "Input(request);"

\&\f(CW\*(C`Input\*(C'\fR is analogous to LaTeX's \f(CW\*(C`\einput\*(C'\fR, and is used in
cases where it isn't completely clear whether content or definitions
is expected.  Once a file is found, the approach specified
by \f(CW\*(C`InputContent\*(C'\fR or \f(CW\*(C`InputDefinitions\*(C'\fR is used, depending on
which type of file is found.
.IX Xref "Input"
.ie n .IP """InputDefinitions(\fIrequest\fP, \fI%options\fP);""" 4
.el .IP "\f(CWInputDefinitions(\f(CIrequest\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "InputDefinitions(request, %options);"

\&\f(CW\*(C`InputDefinitions\*(C'\fR is used for loading \fIdefinitions\fR,
ie. various macros, settings, etc, rather than document content;
it can be used to load LaTeXML's binding files, or for
reading in raw TeX definitions or style files.
It reads and processes the material completely before
returning, even in the case of TeX definitions.
This procedure optionally supports the conventions used
for standard LaTeX packages and classes (see \f(CW\*(C`RequirePackage\*(C'\fR and \f(CW\*(C`LoadClass\*(C'\fR).
.IX Xref "InputDefinitions"
.Sp
Options for \f(CW\*(C`InputDefinitions\*(C'\fR are:
.RS 4
.ie n .IP """type=>\fItype\fP""" 4
.el .IP "\f(CWtype=>\f(CItype\f(CW\fR" 4
.IX Item "type=>type"
the file type to search for.
.ie n .IP """noltxml=>\fIboolean\fP""" 4
.el .IP "\f(CWnoltxml=>\f(CIboolean\f(CW\fR" 4
.IX Item "noltxml=>boolean"
inhibits searching for a LaTeXML binding; only raw TeX files will be sought and loaded.
.ie n .IP """notex=>\fIboolean\fP""" 4
.el .IP "\f(CWnotex=>\f(CIboolean\f(CW\fR" 4
.IX Item "notex=>boolean"
inhibits searching for raw TeX files, only a LaTeXML binding will be sought and loaded.
.ie n .IP """noerror=>\fIboolean\fP""" 4
.el .IP "\f(CWnoerror=>\f(CIboolean\f(CW\fR" 4
.IX Item "noerror=>boolean"
inhibits reporting an error if no appropriate file is found.
.RE
.RS 4
.Sp
The following options are primarily useful when \f(CW\*(C`InputDefinitions\*(C'\fR
is supporting standard LaTeX package and class loading.
.ie n .IP """withoptions=>\fIboolean\fP""" 4
.el .IP "\f(CWwithoptions=>\f(CIboolean\f(CW\fR" 4
.IX Item "withoptions=>boolean"
indicates whether to pass in any options from the calling class or package.
.ie n .IP """handleoptions=>\fIboolean\fP""" 4
.el .IP "\f(CWhandleoptions=>\f(CIboolean\f(CW\fR" 4
.IX Item "handleoptions=>boolean"
indicates whether options processing should be handled.
.ie n .IP """options=>[...]""" 4
.el .IP "\f(CWoptions=>[...]\fR" 4
.IX Item "options=>[...]"
specifies a list of options (in the 'package options' sense) to be passed
(possibly in addition to any provided by the calling class or package).
.ie n .IP """after=>\fItokens\fP | \fIcode\fP($gullet)""" 4
.el .IP "\f(CWafter=>\f(CItokens\f(CW | \f(CIcode\f(CW($gullet)\fR" 4
.IX Item "after=>tokens | code($gullet)"
provides \fItokens\fR or \fIcode\fR to be processed by a \f(CW\*(C`\f(CIname\f(CW.\f(CItype\f(CW\-h@@k\*(C'\fR macro.
.ie n .IP """as_class=>\fIboolean\fP""" 4
.el .IP "\f(CWas_class=>\f(CIboolean\f(CW\fR" 4
.IX Item "as_class=>boolean"
fishy option that indicates that this definitions file should
be treated as if it were defining a class; typically shows up
in latex compatibility mode, or AMSTeX.
.RE
.RS 4
.Sp
A handy method to use most of the TeX distribution's raw TeX definitions for a package,
but override only a few with LaTeXML bindings is by defining a binding file,
say \f(CW\*(C`tikz.sty.ltxml\*(C'\fR, to contain
.Sp
.Vb 1
\&  InputDefinitions(\*(Aqtikz\*(Aq, type => \*(Aqsty\*(Aq, noltxml => 1);
.Ve
.Sp
which would find and read in \f(CW\*(C`tizk.sty\*(C'\fR, and then follow it by a couple of strategic
LaTeXML definitions, \f(CW\*(C`DefMacro\*(C'\fR, etc.
.RE
.SS "Class and Packages"
.IX Subsection "Class and Packages"
.ie n .IP """RequirePackage(\fIpackage\fP, \fI%options\fP);""" 4
.el .IP "\f(CWRequirePackage(\f(CIpackage\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "RequirePackage(package, %options);"

Finds and loads a package implementation (usually \f(CW\*(C`\f(CIpackage\f(CW.sty.ltxml\*(C'\fR,
unless \f(CW\*(C`noltxml\*(C'\fR is specified)for the requested \fIpackage\fR.
It returns the pathname of the loaded package.
The options are:
.IX Xref "RequirePackage"
.RS 4
.ie n .IP """type=>\fItype\fP""" 4
.el .IP "\f(CWtype=>\f(CItype\f(CW\fR" 4
.IX Item "type=>type"
specifies the file type (default \f(CW\*(C`sty\*(C'\fR.
.ie n .IP """options=>[...]""" 4
.el .IP "\f(CWoptions=>[...]\fR" 4
.IX Item "options=>[...]"
specifies a list of package options.
.ie n .IP """noltxml=>\fIboolean\fP""" 4
.el .IP "\f(CWnoltxml=>\f(CIboolean\f(CW\fR" 4
.IX Item "noltxml=>boolean"
inhibits searching for the LaTeXML binding for the file (ie. \f(CW\*(C`\f(CIname\f(CW.\f(CItype\f(CW.ltxml\*(C'\fR
.ie n .IP """notex=>1""" 4
.el .IP "\f(CWnotex=>1\fR" 4
.IX Item "notex=>1"
inhibits searching for raw tex version of the file.
That is, it will \fIonly\fR search for the LaTeXML binding.
.RE
.RS 4
.RE
.ie n .IP """LoadClass(\fIclass\fP, \fI%options\fP);""" 4
.el .IP "\f(CWLoadClass(\f(CIclass\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "LoadClass(class, %options);"

Finds and loads a class definition (usually \f(CW\*(C`\f(CIclass\f(CW.cls.ltxml\*(C'\fR).
It returns the pathname of the loaded class.
The only option is
.IX Xref "LoadClass"
.RS 4
.ie n .IP """options=>[...]""" 4
.el .IP "\f(CWoptions=>[...]\fR" 4
.IX Item "options=>[...]"
specifies a list of class options.
.RE
.RS 4
.RE
.ie n .IP """LoadPool(\fIpool\fP, \fI%options\fP);""" 4
.el .IP "\f(CWLoadPool(\f(CIpool\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "LoadPool(pool, %options);"

Loads a \fIpool\fR file (usually \f(CW\*(C`\f(CIpool\f(CW.pool.ltxml\*(C'\fR),
one of the top-level definition files, such as TeX, LaTeX or AMSTeX.
It returns the pathname of the loaded file.
.IX Xref "LoadPool"
.ie n .IP """DeclareOption(\fIoption\fP, \fItokens\fP | \fIstring\fP | \fIcode\fP($stomach));""" 4
.el .IP "\f(CWDeclareOption(\f(CIoption\f(CW, \f(CItokens\f(CW | \f(CIstring\f(CW | \f(CIcode\f(CW($stomach));\fR" 4
.IX Item "DeclareOption(option, tokens | string | code($stomach));"

Declares an option for the current package or class.
The 2nd argument can be a \fIstring\fR (which will be tokenized and expanded)
or \fItokens\fR (which will be macro expanded), to provide the value for the option,
or it can be a code reference which is treated as a primitive for side-effect.
.IX Xref "DeclareOption"
.Sp
If a package or class wants to accommodate options, it should start
with one or more \f(CW\*(C`DeclareOptions\*(C'\fR, followed by \f(CW\*(C`ProcessOptions()\*(C'\fR.
.ie n .IP """PassOptions(\fIname\fP, \fIext\fP, \fI@options\fP); """ 4
.el .IP "\f(CWPassOptions(\f(CIname\f(CW, \f(CIext\f(CW, \f(CI@options\f(CW); \fR" 4
.IX Item "PassOptions(name, ext, @options); "

Causes the given \fI\f(CI@options\fI\fR (strings) to be passed to the package
(if \fIext\fR is \f(CW\*(C`sty\*(C'\fR) or class (if \fIext\fR is \f(CW\*(C`cls\*(C'\fR)
named by \fIname\fR.
.IX Xref "PassOptions"
.ie n .IP """ProcessOptions(\fI%options\fP);""" 4
.el .IP "\f(CWProcessOptions(\f(CI%options\f(CW);\fR" 4
.IX Item "ProcessOptions(%options);"

Processes the options that have been passed to the current package
or class in a fashion similar to LaTeX.  The only option (to \f(CW\*(C`ProcessOptions\*(C'\fR
is \f(CW\*(C`inorder=>\f(CIboolean\f(CW\*(C'\fR indicating whehter the (package) options are processed in the
order they were used, like \f(CW\*(C`ProcessOptions*\*(C'\fR.
.IX Xref "ProcessOptions"
.Sp
This will also process a limited form of keyval class and package options,
if option \f(CW\*(C`keysets\*(C'\fR provides a list of keyval set names, and option \f(CW\*(C`inorder\*(C'\fR is true.
.ie n .IP """ExecuteOptions(\fI@options\fP);""" 4
.el .IP "\f(CWExecuteOptions(\f(CI@options\f(CW);\fR" 4
.IX Item "ExecuteOptions(@options);"

Process the options given explicitly in \fI\f(CI@options\fI\fR.
.IX Xref "ExecuteOptions"
.ie n .IP """AtBeginDocument(\fI@stuff\fP); """ 4
.el .IP "\f(CWAtBeginDocument(\f(CI@stuff\f(CW); \fR" 4
.IX Item "AtBeginDocument(@stuff); "

Arranges for \fI\f(CI@stuff\fI\fR to be carried out after the preamble, at the beginning of the document.
\&\fI\f(CI@stuff\fI\fR should typically be macro-level stuff, but carried out for side effect;
it should be tokens, tokens lists, strings (which will be tokenized),
or \f(CW\*(C`\f(CIcode\f(CW($gullet)\*(C'\fR which would yield tokens to be expanded.
.IX Xref "AtBeginDocument"
.Sp
This operation is useful for style files loaded with \f(CW\*(C`\-\-preload\*(C'\fR or document specific
customization files (ie. ending with \f(CW\*(C`.latexml\*(C'\fR); normally the contents would be executed
before LaTeX and other style files are loaded and thus can be overridden by them.
By deferring the evaluation to begin-document time, these contents can override those style files.
This is likely to only be meaningful for LaTeX documents.
.ie n .IP """AtEndDocument(\fI@stuff\fP)""" 4
.el .IP "\f(CWAtEndDocument(\f(CI@stuff\f(CW)\fR" 4
.IX Item "AtEndDocument(@stuff)"
Arranges for \fI\f(CI@stuff\fI\fR to be carried out just before \f(CW\*(C`\e\eend{document}\*(C'\fR.
These tokens can be used for side effect, or any content they generate will appear as the
last children of the document.
.SS "Counters and IDs"
.IX Subsection "Counters and IDs"
.ie n .IP """NewCounter(\fIctr\fP, \fIwithin\fP, \fI%options\fP);""" 4
.el .IP "\f(CWNewCounter(\f(CIctr\f(CW, \f(CIwithin\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "NewCounter(ctr, within, %options);"

Defines a new counter, like LaTeX's \enewcounter, but extended.
It defines a counter that can be used to generate reference numbers,
and defines \f(CW\*(C`\ethe\f(CIctr\f(CW\*(C'\fR, etc. It also defines an \*(L"uncounter\*(R" which
can be used to generate \s-1ID\s0's (xml:id) for unnumbered objects.
\&\fIctr\fR is the name of the counter.  If defined, \fIwithin\fR is the name
of another counter which, when incremented, will cause this counter
to be reset.
The options are
.IX Xref "NewCounter"
.RS 4
.ie n .IP """idprefix=>\fIstring\fP""" 4
.el .IP "\f(CWidprefix=>\f(CIstring\f(CW\fR" 4
.IX Item "idprefix=>string"
Specifies a prefix to be used to generate \s-1ID\s0's when using this counter
.ie n .IP """nested""" 4
.el .IP "\f(CWnested\fR" 4
.IX Item "nested"
Not sure that this is even sane.
.RE
.RS 4
.RE
.ie n .IP """$num = CounterValue($ctr);""" 4
.el .IP "\f(CW$num = CounterValue($ctr);\fR" 4
.IX Item "$num = CounterValue($ctr);"

Fetches the value associated with the counter \f(CW$ctr\fR.
.IX Xref "CounterValue"
.ie n .IP """$tokens = StepCounter($ctr);""" 4
.el .IP "\f(CW$tokens = StepCounter($ctr);\fR" 4
.IX Item "$tokens = StepCounter($ctr);"

Analog of \f(CW\*(C`\estepcounter\*(C'\fR, steps the counter and returns the expansion of
\&\f(CW\*(C`\ethe$ctr\*(C'\fR.  Usually you should use \f(CW\*(C`RefStepCounter($ctr)\*(C'\fR instead.
.IX Xref "StepCounter"
.ie n .IP """$keys = RefStepCounter($ctr);""" 4
.el .IP "\f(CW$keys = RefStepCounter($ctr);\fR" 4
.IX Item "$keys = RefStepCounter($ctr);"

Analog of \f(CW\*(C`\erefstepcounter\*(C'\fR, steps the counter and returns a hash
containing the keys \f(CW\*(C`refnum=\*(C'\fR\f(CW$refnum\fR, id=>$id>.  This makes it
suitable for use in a \f(CW\*(C`properties\*(C'\fR option to constructors.
The \f(CW\*(C`id\*(C'\fR is generated in parallel with the reference number
to assist debugging.
.IX Xref "RefStepCounter"
.ie n .IP """$keys = RefStepID($ctr);""" 4
.el .IP "\f(CW$keys = RefStepID($ctr);\fR" 4
.IX Item "$keys = RefStepID($ctr);"

Like to \f(CW\*(C`RefStepCounter\*(C'\fR, but only steps the \*(L"uncounter\*(R",
and returns only the id;  This is useful for unnumbered cases
of objects that normally get both a refnum and id.
.IX Xref "RefStepID"
.ie n .IP """ResetCounter($ctr);""" 4
.el .IP "\f(CWResetCounter($ctr);\fR" 4
.IX Item "ResetCounter($ctr);"

Resets the counter \f(CW$ctr\fR to zero.
.IX Xref "ResetCounter"
.ie n .IP """GenerateID($document,$node,$whatsit,$prefix);""" 4
.el .IP "\f(CWGenerateID($document,$node,$whatsit,$prefix);\fR" 4
.IX Item "GenerateID($document,$node,$whatsit,$prefix);"

Generates an \s-1ID\s0 for nodes during the construction phase, useful
for cases where the counter based scheme is inappropriate.
The calling pattern makes it appropriate for use in Tag, as in
.IX Xref "GenerateID"
.Sp
.Vb 1
\&   Tag(\*(Aqltx:para\*(Aq,afterClose=>sub { GenerateID(@_,\*(Aqp\*(Aq); })
.Ve
.Sp
If \f(CW$node\fR doesn't already have an xml:id set, it computes an
appropriate id by concatenating the xml:id of the closest
ancestor with an id (if any), the prefix (if any) and a unique counter.
.SS "Document Model"
.IX Subsection "Document Model"
Constructors define how TeX markup will generate \s-1XML\s0 fragments, but the
Document Model is used to control exactly how those fragments are assembled.
.ie n .IP """Tag(\fItag\fP, \fI%properties\fP);""" 4
.el .IP "\f(CWTag(\f(CItag\f(CW, \f(CI%properties\f(CW);\fR" 4
.IX Item "Tag(tag, %properties);"

Declares properties of elements with the name \fItag\fR.
Note that \f(CW\*(C`Tag\*(C'\fR can set or add properties to any element from any binding file,
unlike the properties set on control by  \f(CW\*(C`DefPrimtive\*(C'\fR, \f(CW\*(C`DefConstructor\*(C'\fR, etc..
And, since the properties are recorded in the current Model, they are not
subject to TeX grouping; once set, they remain in effect until changed
or the end of the document.
.IX Xref "Tag"
.Sp
The \fItag\fR can be specified in one of three forms:
.Sp
.Vb 3
\&   prefix:name matches specific name in specific namespace
\&   prefix:*    matches any tag in the specific namespace;
\&   *           matches any tag in any namespace.
.Ve
.Sp
There are two kinds of properties:
.RS 4
.IP "Scalar properties" 4
.IX Item "Scalar properties"
For scalar properties, only a single value is returned for a given element.
When the property is looked up, each of the above forms is considered
(the specific element name, the namespace, and all elements);
the first defined value is returned.
.Sp
The recognized scalar properties are:
.RS 4
.ie n .IP """autoOpen=>\fIboolean\fP""" 4
.el .IP "\f(CWautoOpen=>\f(CIboolean\f(CW\fR" 4
.IX Item "autoOpen=>boolean"
Specifies whether \fItag\fR can be automatically opened
if needed to insert an element that can only be contained by \fItag\fR.
This property can help match the more  SGML-like LaTeX to \s-1XML.\s0
.ie n .IP """autoClose=>\fIboolean\fP""" 4
.el .IP "\f(CWautoClose=>\f(CIboolean\f(CW\fR" 4
.IX Item "autoClose=>boolean"
Specifies whether this \fItag\fR can be automatically closed
if needed to close an ancestor node, or insert
an element into an ancestor.
This property can help match the more  SGML-like LaTeX to \s-1XML.\s0
.RE
.RS 4
.RE
.IP "Code properties" 4
.IX Item "Code properties"
These properties provide a bit of code to be run at the times
of certain events associated with an element.  \fIAll\fR the code bits
that match a given element will be run, and since they can be added by
any binding file, and be specified in a random orders,
a little bit of extra control is desirable.
.Sp
Firstly, any \fIearly\fR codes are run (eg \f(CW\*(C`afterOpen:early\*(C'\fR), then
any normal codes (without modifier) are run, and finally
any \fIlate\fR codes are run (eg. \f(CW\*(C`afterOpen:late\*(C'\fR).
.Sp
Within \fIeach\fR of those groups, the codes assigned for an element's specific
name are run first, then those assigned for its package and finally the generic one (\f(CW\*(C`*\*(C'\fR);
that is, the most specific codes are run first.
.Sp
When code properties are accumulated by \f(CW\*(C`Tag\*(C'\fR for normal or late events,
the code is appended to the end of the current list (if there were any previous codes added);
for early event, the code is prepended.
.Sp
The recognized code properties are:
.RS 4
.ie n .IP """afterOpen=>\fIcode\fP($document,$box)""" 4
.el .IP "\f(CWafterOpen=>\f(CIcode\f(CW($document,$box)\fR" 4
.IX Item "afterOpen=>code($document,$box)"
Provides \fIcode\fR to be run whenever a node with this \fItag\fR
is opened.  It is called with the document being constructed,
and the initiating digested object as arguments.
It is called after the node has been created, and after
any initial attributes due to the constructor (passed to openElement)
are added.
.Sp
\&\f(CW\*(C`afterOpen:early\*(C'\fR or \f(CW\*(C`afterOpen:late\*(C'\fR can be used in
place of \f(CW\*(C`afterOpen\*(C'\fR; these will be run as a group
before, or after (respectively) the unmodified blocks.
.ie n .IP """afterClose=>\fIcode\fP($document,$box)""" 4
.el .IP "\f(CWafterClose=>\f(CIcode\f(CW($document,$box)\fR" 4
.IX Item "afterClose=>code($document,$box)"
Provides \fIcode\fR to be run whenever a node with this \fItag\fR
is closed.  It is called with the document being constructed,
and the initiating digested object as arguments.
.Sp
\&\f(CW\*(C`afterClose:early\*(C'\fR or \f(CW\*(C`afterClose:late\*(C'\fR can be used in
place of \f(CW\*(C`afterClose\*(C'\fR; these will be run as a group
bfore, or after (respectively) the unmodified blocks.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .IP """RelaxNGSchema(\fIschemaname\fP);""" 4
.el .IP "\f(CWRelaxNGSchema(\f(CIschemaname\f(CW);\fR" 4
.IX Item "RelaxNGSchema(schemaname);"

Specifies the schema to use for determining document model.
You can leave off the extension; it will look for \f(CW\*(C`\f(CIschemaname\f(CW.rng\*(C'\fR
(and maybe eventually, \f(CW\*(C`.rnc\*(C'\fR if that is ever implemented).
.IX Xref "RelaxNGSchema"
.ie n .IP """RegisterNamespace(\fIprefix\fP, \fIURL\fP);""" 4
.el .IP "\f(CWRegisterNamespace(\f(CIprefix\f(CW, \f(CIURL\f(CW);\fR" 4
.IX Item "RegisterNamespace(prefix, URL);"

Declares the \fIprefix\fR to be associated with the given \fI\s-1URL\s0\fR.
These prefixes may be used in ltxml files, particularly for
constructors, xpath expressions, etc.  They are not necessarily
the same as the prefixes that will be used in the generated document
Use the prefix \f(CW\*(C`#default\*(C'\fR for the default, non-prefixed, namespace.
(See RegisterDocumentNamespace, as well as DocType or RelaxNGSchema).
.IX Xref "RegisterNamespace"
.ie n .IP """RegisterDocumentNamespace(\fIprefix\fP, \fIURL\fP);""" 4
.el .IP "\f(CWRegisterDocumentNamespace(\f(CIprefix\f(CW, \f(CIURL\f(CW);\fR" 4
.IX Item "RegisterDocumentNamespace(prefix, URL);"

Declares the \fIprefix\fR to be associated with the given \fI\s-1URL\s0\fR
used within the generated \s-1XML.\s0 They are not necessarily
the same as the prefixes used in code (RegisterNamespace).
This function is less rarely needed, as the namespace declarations
are generally obtained from the \s-1DTD\s0 or Schema themselves
Use the prefix \f(CW\*(C`#default\*(C'\fR for the default, non-prefixed, namespace.
(See DocType or RelaxNGSchema).
.IX Xref "RegisterDocumentNamespace"
.ie n .IP """DocType(\fIrootelement\fP, \fIpublicid\fP, \fIsystemid\fP, \fI%namespaces\fP);""" 4
.el .IP "\f(CWDocType(\f(CIrootelement\f(CW, \f(CIpublicid\f(CW, \f(CIsystemid\f(CW, \f(CI%namespaces\f(CW);\fR" 4
.IX Item "DocType(rootelement, publicid, systemid, %namespaces);"

Declares the expected \fIrootelement\fR, the public and system \s-1ID\s0's of the document type
to be used in the final document.  The hash \fI\f(CI%namespaces\fI\fR specifies
the namespaces prefixes that are expected to be found in the \s-1DTD,\s0 along with
each associated namespace \s-1URI.\s0  Use the prefix \f(CW\*(C`#default\*(C'\fR for the default namespace
(ie. the namespace of non-prefixed elements in the \s-1DTD\s0).
.IX Xref "DocType"
.Sp
The prefixes defined for the \s-1DTD\s0 may be different from the prefixes used in
implementation \s-1CODE\s0 (eg. in ltxml files; see RegisterNamespace).
The generated document will use the namespaces and prefixes defined for the \s-1DTD.\s0
.SS "Document Rewriting"
.IX Subsection "Document Rewriting"
During document construction, as each node gets closed, the text content gets simplfied.
We'll call it \fIapplying ligatures\fR, for lack of a better name.
.ie n .IP """DefLigature(\fIregexp\fP, \fI%options\fP);""" 4
.el .IP "\f(CWDefLigature(\f(CIregexp\f(CW, \f(CI%options\f(CW);\fR" 4
.IX Item "DefLigature(regexp, %options);"

Apply the regular expression (given as a string: \*(L"/fa/fa/\*(R" since it will
be converted internally to a true regexp), to the text content.
The only option is \f(CW\*(C`fontTest=>\f(CIcode\f(CW($font)\*(C'\fR; if given, then the substitution
is applied only when \f(CW\*(C`fontTest\*(C'\fR returns true.
.IX Xref "DefLigature"
.Sp
Predefined Ligatures combine sequences of \*(L".\*(R" or single-quotes into appropriate
Unicode characters.
.ie n .IP """DefMathLigature(\fI$string\fP\f(CW""=""\f(CW""\fI\f(CI$replacment\fI\fR,\fI\f(CI%options\fI\fR);>" 4
.el .IP "\f(CWDefMathLigature(\f(CI$string\f(CW\f(CW=\f(CW\fR\fI\f(CI$replacment\fI\fR,\fI\f(CI%options\fI\fR);>" 4
.IX Item "DefMathLigature($string=$replacment,%options);>"

A Math Ligature typically combines a sequence of math tokens (XMTok) into a single one.
A simple example is
.IX Xref "DefMathLigature"
.Sp
.Vb 1
\&   DefMathLigature(":=" => ":=", role => \*(AqRELOP\*(Aq, meaning => \*(Aqassign\*(Aq);
.Ve
.Sp
replaces the two tokens for colon and equals by a token representing assignment.
The options are those characterising an XMTok, namely: \f(CW\*(C`role\*(C'\fR, \f(CW\*(C`meaning\*(C'\fR and \f(CW\*(C`name\*(C'\fR.
.Sp
For more complex cases (recognizing numbers, for example), you may supply a
function \f(CW\*(C`matcher=\*(C'\fR\s-1CODE\s0($document,$node)>, which is passed the current document
and the last math node in the sequence.  It should examine \f(CW$node\fR and any preceding
nodes (using \f(CW\*(C`previousSibling\*(C'\fR) and return a list of \f(CW\*(C`($n,$string,%attributes)\*(C'\fR to replace
the \f(CW$n\fR nodes by a new one with text content being \f(CW$string\fR content and the given attributes.
If no replacement is called for, \s-1CODE\s0 should return undef.
.PP
After document construction, various rewriting and augmenting of the
document can take place.
.ie n .IP """DefRewrite(\fI%specification\fP);""" 4
.el .IP "\f(CWDefRewrite(\f(CI%specification\f(CW);\fR" 4
.IX Item "DefRewrite(%specification);"
.PD 0
.ie n .IP """DefMathRewrite(\fI%specification\fP);""" 4
.el .IP "\f(CWDefMathRewrite(\f(CI%specification\f(CW);\fR" 4
.IX Item "DefMathRewrite(%specification);"
.PD

These two declarations define document rewrite rules that are applied to the
document tree after it has been constructed, but before math parsing, or
any other postprocessing, is done.  The \fI\f(CI%specification\fI\fR consists of a
sequence of key/value pairs with the initial specs successively narrowing the
selection of document nodes, and the remaining specs indicating how
to modify or replace the selected nodes.
.IX Xref "DefRewrite DefMathRewrite"
.Sp
The following select portions of the document:
.RS 4
.ie n .IP """label=>\fIlabel\fP""" 4
.el .IP "\f(CWlabel=>\f(CIlabel\f(CW\fR" 4
.IX Item "label=>label"
Selects the part of the document with label=$label
.ie n .IP """scope=>\fIscope\fP""" 4
.el .IP "\f(CWscope=>\f(CIscope\f(CW\fR" 4
.IX Item "scope=>scope"
The \fIscope\fR could be \*(L"label:foo\*(R" or \*(L"section:1.2.3\*(R" or something
similar. These select a subtree labelled 'foo', or
a section with reference number \*(L"1.2.3\*(R"
.ie n .IP """xpath=>\fIxpath\fP""" 4
.el .IP "\f(CWxpath=>\f(CIxpath\f(CW\fR" 4
.IX Item "xpath=>xpath"
Select those nodes matching an explicit xpath expression.
.ie n .IP """match=>\fItex\fP""" 4
.el .IP "\f(CWmatch=>\f(CItex\f(CW\fR" 4
.IX Item "match=>tex"
Selects nodes that look like what the processing of \fItex\fR would produce.
.ie n .IP """regexp=>\fIregexp\fP""" 4
.el .IP "\f(CWregexp=>\f(CIregexp\f(CW\fR" 4
.IX Item "regexp=>regexp"
Selects text nodes that match the regular expression.
.RE
.RS 4
.Sp
The following act upon the selected node:
.ie n .IP """attributes=>\fIhashref\fP""" 4
.el .IP "\f(CWattributes=>\f(CIhashref\f(CW\fR" 4
.IX Item "attributes=>hashref"
Adds the attributes given in the hash reference to the node.
.ie n .IP """replace=>\fIreplacement\fP""" 4
.el .IP "\f(CWreplace=>\f(CIreplacement\f(CW\fR" 4
.IX Item "replace=>replacement"
Interprets \fIreplacement\fR as TeX code to generate nodes that will
replace the selected nodes.
.RE
.RS 4
.RE
.SS "Mid-Level support"
.IX Subsection "Mid-Level support"
.ie n .IP """$tokens = Expand($tokens);""" 4
.el .IP "\f(CW$tokens = Expand($tokens);\fR" 4
.IX Item "$tokens = Expand($tokens);"

Expands the given \f(CW$tokens\fR according to current definitions.
.IX Xref "Expand"
.ie n .IP """$boxes = Digest($tokens);""" 4
.el .IP "\f(CW$boxes = Digest($tokens);\fR" 4
.IX Item "$boxes = Digest($tokens);"

Processes and digestes the \f(CW$tokens\fR.  Any arguments needed by
control sequences in \f(CW$tokens\fR must be contained within the \f(CW$tokens\fR itself.
.IX Xref "Digest"
.ie n .IP """@tokens = Invocation($cs,@args);""" 4
.el .IP "\f(CW@tokens = Invocation($cs,@args);\fR" 4
.IX Item "@tokens = Invocation($cs,@args);"

Constructs a sequence of tokens that would invoke the token \f(CW$cs\fR
on the arguments.
.IX Xref "Invocation"
.ie n .IP """RawTeX(\*(Aq... tex code ...\*(Aq);""" 4
.el .IP "\f(CWRawTeX(\*(Aq... tex code ...\*(Aq);\fR" 4
.IX Item "RawTeX(... tex code ...);"

RawTeX is a convenience function for including chunks of raw TeX (or LaTeX) code
in a Package implementation.  It is useful for copying portions of the normal
implementation that can be handled simply using macros and primitives.
.IX Xref "RawTeX"
.ie n .IP """Let($token1,$token2);""" 4
.el .IP "\f(CWLet($token1,$token2);\fR" 4
.IX Item "Let($token1,$token2);"

Gives \f(CW$token1\fR the same `meaning' (definition) as \f(CW$token2\fR; like TeX's \elet.
.IX Xref "Let"
.ie n .IP """StartSemiVerbatim(); ... ; EndSemiVerbatim();""" 4
.el .IP "\f(CWStartSemiVerbatim(); ... ; EndSemiVerbatim();\fR" 4
.IX Item "StartSemiVerbatim(); ... ; EndSemiVerbatim();"
Disable disable most TeX catcodes.
.ie n .IP """$tokens = Tokenize($string);""" 4
.el .IP "\f(CW$tokens = Tokenize($string);\fR" 4
.IX Item "$tokens = Tokenize($string);"
Tokenizes the \f(CW$string\fR using the standard catcodes, returning a LaTeXML::Core::Tokens.
.ie n .IP """$tokens = TokenizeInternal($string);""" 4
.el .IP "\f(CW$tokens = TokenizeInternal($string);\fR" 4
.IX Item "$tokens = TokenizeInternal($string);"
Tokenizes the \f(CW$string\fR according to the internal cattable (where @ is a letter),
returning a LaTeXML::Core::Tokens.
.SS "Argument Readers"
.IX Subsection "Argument Readers"
.ie n .IP """ReadParameters($gullet,$spec);""" 4
.el .IP "\f(CWReadParameters($gullet,$spec);\fR" 4
.IX Item "ReadParameters($gullet,$spec);"

Reads from \f(CW$gullet\fR the tokens corresponding to \f(CW$spec\fR
(a Parameters object).
.IX Xref "ReadParameters"
.ie n .IP """DefParameterType(\fItype\fP, \fIcode\fP($gullet,@values), \fI%options\fP);""" 4
.el .IP "\f(CWDefParameterType(\f(CItype\f(CW, \f(CIcode\f(CW($gullet,@values), \f(CI%options\f(CW);\fR" 4
.IX Item "DefParameterType(type, code($gullet,@values), %options);"

Defines a new Parameter type, \fItype\fR, with \fIcode\fR for its reader.
.IX Xref "DefParameterType"
.Sp
Options are:
.RS 4
.ie n .IP """reversion=>\fIcode\fP($arg,@values);""" 4
.el .IP "\f(CWreversion=>\f(CIcode\f(CW($arg,@values);\fR" 4
.IX Item "reversion=>code($arg,@values);"
This \fIcode\fR is responsible for converting a previously parsed argument back
into a sequence of Token's.
.ie n .IP """optional=>\fIboolean\fP""" 4
.el .IP "\f(CWoptional=>\f(CIboolean\f(CW\fR" 4
.IX Item "optional=>boolean"
whether it is an error if no matching input is found.
.ie n .IP """novalue=>\fIboolean\fP""" 4
.el .IP "\f(CWnovalue=>\f(CIboolean\f(CW\fR" 4
.IX Item "novalue=>boolean"
whether the value returned should contribute to argument lists, or
simply be passed over.
.ie n .IP """semiverbatim=>\fIboolean\fP""" 4
.el .IP "\f(CWsemiverbatim=>\f(CIboolean\f(CW\fR" 4
.IX Item "semiverbatim=>boolean"
whether the catcode table should be modified before reading tokens.
.RE
.RS 4
.RE
.ie n .IP """<DefColumnType(\fIproto\fP, \fIexpansion\fP);""" 4
.el .IP "\f(CW<DefColumnType(\f(CIproto\f(CW, \f(CIexpansion\f(CW);\fR" 4
.IX Item "<DefColumnType(proto, expansion);"

Defines a new column type for tabular and arrays.
\&\fIproto\fR is the prototype for the pattern, analogous to the pattern
used for other definitions, except that macro being defined is a single character.
The \fIexpansion\fR is a string specifying what it should expand into,
typically more verbose column specification.
.IX Xref "DefColumnType"
.SS "Access to State"
.IX Subsection "Access to State"
.ie n .IP """$value = LookupValue($name);""" 4
.el .IP "\f(CW$value = LookupValue($name);\fR" 4
.IX Item "$value = LookupValue($name);"

Lookup the current value associated with the the string \f(CW$name\fR.
.IX Xref "LookupValue"
.ie n .IP """AssignValue($name,$value,$scope);""" 4
.el .IP "\f(CWAssignValue($name,$value,$scope);\fR" 4
.IX Item "AssignValue($name,$value,$scope);"

Assign \f(CW$value\fR to be associated with the the string \f(CW$name\fR, according
to the given scoping rule.
.IX Xref "AssignValue"
.Sp
Values are also used to specify most configuration parameters (which can
therefore also be scoped).  The recognized configuration parameters are:
.Sp
.Vb 10
\& STRICT            : whether errors (eg. undefined macros)
\&                     are fatal.
\& INCLUDE_COMMENTS  : whether to preserve comments in the
\&                     source, and to add occasional line
\&                     number comments. (Default true).
\& PRESERVE_NEWLINES : whether newlines in the source should
\&                     be preserved (not 100% TeX\-like).
\&                     By default this is true.
\& SEARCHPATHS       : a list of directories to search for
\&                     sources, implementations, etc.
.Ve
.ie n .IP """PushValue($name,@values);""" 4
.el .IP "\f(CWPushValue($name,@values);\fR" 4
.IX Item "PushValue($name,@values);"

This function, along with the next three are like \f(CW\*(C`AssignValue\*(C'\fR,
but maintain a global list of values.
\&\f(CW\*(C`PushValue\*(C'\fR pushes the provided values onto the end of a list.
The data stored for \f(CW$name\fR is global and must be a \s-1LIST\s0 reference; it is created if needed.
.IX Xref "PushValue"
.ie n .IP """UnshiftValue($name,@values);""" 4
.el .IP "\f(CWUnshiftValue($name,@values);\fR" 4
.IX Item "UnshiftValue($name,@values);"

Similar to  \f(CW\*(C`PushValue\*(C'\fR, but pushes a value onto the front of the list.
The data stored for \f(CW$name\fR is global and must be a \s-1LIST\s0 reference; it is created if needed.
.IX Xref "UnshiftValue"
.ie n .IP """PopValue($name);""" 4
.el .IP "\f(CWPopValue($name);\fR" 4
.IX Item "PopValue($name);"

Removes and returns the value on the end of the list named by \f(CW$name\fR.
The data stored for \f(CW$name\fR is global and must be a \s-1LIST\s0 reference.
Returns \f(CW\*(C`undef\*(C'\fR if there is no data in the list.
.IX Xref "PopValue"
.ie n .IP """ShiftValue($name);""" 4
.el .IP "\f(CWShiftValue($name);\fR" 4
.IX Item "ShiftValue($name);"

Removes and returns the first value in the list named by \f(CW$name\fR.
The data stored for \f(CW$name\fR is global and must be a \s-1LIST\s0 reference.
Returns \f(CW\*(C`undef\*(C'\fR if there is no data in the list.
.IX Xref "ShiftValue"
.ie n .IP """LookupMapping($name,$key);""" 4
.el .IP "\f(CWLookupMapping($name,$key);\fR" 4
.IX Item "LookupMapping($name,$key);"

This function maintains a hash association named by \f(CW$name\fR.
It returns the value associated with \f(CW$key\fR within that mapping.
The data stored for \f(CW$name\fR is global and must be a \s-1HASH\s0 reference.
Returns \f(CW\*(C`undef\*(C'\fR if there is no data associated with \f(CW$key\fR in the mapping,
or the mapping is not (yet) defined.
.IX Xref "LookupMapping"
.ie n .IP """AssignMapping($name,$key,$value);""" 4
.el .IP "\f(CWAssignMapping($name,$key,$value);\fR" 4
.IX Item "AssignMapping($name,$key,$value);"

This function associates \f(CW$value\fR with \f(CW$key\fR within the mapping named by \f(CW$name\fR.
The data stored for \f(CW$name\fR is global and must be a \s-1HASH\s0 reference; it is created if needed.
.IX Xref "AssignMapping"
.ie n .IP """$value = LookupCatcode($char);""" 4
.el .IP "\f(CW$value = LookupCatcode($char);\fR" 4
.IX Item "$value = LookupCatcode($char);"

Lookup the current catcode associated with the the character \f(CW$char\fR.
.IX Xref "LookupCatcode"
.ie n .IP """AssignCatcode($char,$catcode,$scope);""" 4
.el .IP "\f(CWAssignCatcode($char,$catcode,$scope);\fR" 4
.IX Item "AssignCatcode($char,$catcode,$scope);"

Set \f(CW$char\fR to have the given \f(CW$catcode\fR, with the assignment made
according to the given scoping rule.
.IX Xref "AssignCatcode"
.Sp
This method is also used to specify whether a given character is
active in math mode, by using \f(CW\*(C`math:$char\*(C'\fR for the character,
and using a value of 1 to specify that it is active.
.ie n .IP """$meaning = LookupMeaning($token);""" 4
.el .IP "\f(CW$meaning = LookupMeaning($token);\fR" 4
.IX Item "$meaning = LookupMeaning($token);"

Looks up the current meaning of the given \f(CW$token\fR which may be a
Definition, another token, or the token itself if it has not
otherwise been defined.
.IX Xref "LookupMeaning"
.ie n .IP """$defn = LookupDefinition($token);""" 4
.el .IP "\f(CW$defn = LookupDefinition($token);\fR" 4
.IX Item "$defn = LookupDefinition($token);"

Looks up the current definition, if any, of the \f(CW$token\fR.
.IX Xref "LookupDefinition"
.ie n .IP """InstallDefinition($defn);""" 4
.el .IP "\f(CWInstallDefinition($defn);\fR" 4
.IX Item "InstallDefinition($defn);"

Install the Definition \f(CW$defn\fR into \f(CW$STATE\fR under its
control sequence.
.IX Xref "InstallDefinition"
.ie n .IP """XEquals($token1,$token2)""" 4
.el .IP "\f(CWXEquals($token1,$token2)\fR" 4
.IX Item "XEquals($token1,$token2)"
Tests whether the two tokens are equal in the sense that they are either equal
tokens, or if defined, have the same definition.
.SS "Fonts"
.IX Subsection "Fonts"
.ie n .IP """MergeFont(\fI%fontspec\fP); """ 4
.el .IP "\f(CWMergeFont(\f(CI%fontspec\f(CW); \fR" 4
.IX Item "MergeFont(%fontspec); "

Set the current font by merging the font style attributes with the current font.
The \fI\f(CI%fontspec\fI\fR specifies the properties of the desired font.
Likely values include (the values aren't required to be in this set):
.IX Xref "MergeFont"
.Sp
.Vb 7
\& family : serif, sansserif, typewriter, caligraphic,
\&          fraktur, script
\& series : medium, bold
\& shape  : upright, italic, slanted, smallcaps
\& size   : tiny, footnote, small, normal, large,
\&          Large, LARGE, huge, Huge
\& color  : any named color, default is black
.Ve
.Sp
Some families will only be used in math.
This function returns nothing so it can be easily used in beforeDigest, afterDigest.
.ie n .IP """DeclareFontMap($name,$map,%options);""" 4
.el .IP "\f(CWDeclareFontMap($name,$map,%options);\fR" 4
.IX Item "DeclareFontMap($name,$map,%options);"
Declares a font map for the encoding \f(CW$name\fR. The map \f(CW$map\fR
is an array of 128 or 256 entries, each element is either a unicode
string for the representation of that codepoint, or undef if that
codepoint is not supported  by this encoding.  The only option
currently is \f(CW\*(C`family\*(C'\fR used because some fonts (notably cmr!)
have different glyphs in some font families, such as
\&\f(CW\*(C`family=\*(C'\fR'typewriter'>.
.ie n .IP """FontDecode($code,$encoding,$implicit);""" 4
.el .IP "\f(CWFontDecode($code,$encoding,$implicit);\fR" 4
.IX Item "FontDecode($code,$encoding,$implicit);"
Returns the unicode string representing the given codepoint \f(CW$code\fR
(an integer) in the given font encoding \f(CW$encoding\fR.
If \f(CW$encoding\fR is undefined, the usual case, the current font encoding
and font family is used for the lookup.  Explicit decoding is
used when \f(CW\*(C`\e\echar\*(C'\fR or similar are invoked (\f(CW$implicit\fR is false), and
the codepoint must be represented in the fontmap, otherwise undef is returned.
Implicit decoding (ie. \f(CW$implicit\fR is true) occurs within the Stomach
when a Token's content is being digested and converted to a Box; in that case
only the lower 128 codepoints are converted; all codepoints above 128 are assumed to already be Unicode.
.Sp
The font map for \f(CW$encoding\fR is automatically loaded if it has not already been loaded.
.ie n .IP """FontDecodeString($string,$encoding,$implicit);""" 4
.el .IP "\f(CWFontDecodeString($string,$encoding,$implicit);\fR" 4
.IX Item "FontDecodeString($string,$encoding,$implicit);"
Returns the unicode string resulting from decoding the individual
characters in \f(CW$string\fR according to FontDecode, above.
.ie n .IP """LoadFontMap($encoding);""" 4
.el .IP "\f(CWLoadFontMap($encoding);\fR" 4
.IX Item "LoadFontMap($encoding);"
Finds and loads the font map for the encoding named \f(CW$encoding\fR, if it hasn't been
loaded before.  It looks for \f(CW\*(C`encoding.fontmap.ltxml\*(C'\fR, which would typically define
the font map using \f(CW\*(C`DeclareFontMap\*(C'\fR, possibly including extra maps for families
like \f(CW\*(C`typewriter\*(C'\fR.
.SS "Color"
.IX Subsection "Color"
.ie n .IP """$color=LookupColor($name);""" 4
.el .IP "\f(CW$color=LookupColor($name);\fR" 4
.IX Item "$color=LookupColor($name);"
Lookup the color object associated with \f(CW$name\fR.
.ie n .IP """DefColor($name,$color,$scope);""" 4
.el .IP "\f(CWDefColor($name,$color,$scope);\fR" 4
.IX Item "DefColor($name,$color,$scope);"
Associates the \f(CW$name\fR with the given \f(CW$color\fR (a color object),
with the given scoping.
.ie n .IP """DefColorModel($model,$coremodel,$tocore,$fromcore);""" 4
.el .IP "\f(CWDefColorModel($model,$coremodel,$tocore,$fromcore);\fR" 4
.IX Item "DefColorModel($model,$coremodel,$tocore,$fromcore);"
Defines a color model \f(CW$model\fR that is derived from the core color
model \f(CW$coremodel\fR.  The two functions \f(CW$tocore\fR and \f(CW$fromcore\fR
convert a color object in that model to the core model, or from the core model
to the derived model.  Core models are rgb, cmy, cmyk, hsb and gray.
.SS "Low-level Functions"
.IX Subsection "Low-level Functions"
.ie n .IP """CleanID($id);""" 4
.el .IP "\f(CWCleanID($id);\fR" 4
.IX Item "CleanID($id);"

Cleans an \f(CW$id\fR of disallowed characters, trimming space.
.IX Xref "CleanID"
.ie n .IP """CleanLabel($label,$prefix);""" 4
.el .IP "\f(CWCleanLabel($label,$prefix);\fR" 4
.IX Item "CleanLabel($label,$prefix);"

Cleans a \f(CW$label\fR of disallowed characters, trimming space.
The prefix \f(CW$prefix\fR is prepended (or \f(CW\*(C`LABEL\*(C'\fR, if none given).
.IX Xref "CleanLabel"
.ie n .IP """CleanIndexKey($key);""" 4
.el .IP "\f(CWCleanIndexKey($key);\fR" 4
.IX Item "CleanIndexKey($key);"

Cleans an index key, so it can be used as an \s-1ID.\s0
.IX Xref "CleanIndexKey"
.ie n .IP """CleanBibKey($key);""" 4
.el .IP "\f(CWCleanBibKey($key);\fR" 4
.IX Item "CleanBibKey($key);"
Cleans a bibliographic citation key, so it can be used as an \s-1ID.\s0
.ie n .IP """CleanURL($url);""" 4
.el .IP "\f(CWCleanURL($url);\fR" 4
.IX Item "CleanURL($url);"

Cleans a url.
.IX Xref "CleanURL"
.ie n .IP """UTF($code);""" 4
.el .IP "\f(CWUTF($code);\fR" 4
.IX Item "UTF($code);"

Generates a \s-1UTF\s0 character, handy for the the 8 bit characters.
For example, \f(CW\*(C`UTF(0xA0)\*(C'\fR generates the non-breaking space.
.IX Xref "UTF"
.ie n .IP """@tokens = roman($number);""" 4
.el .IP "\f(CW@tokens = roman($number);\fR" 4
.IX Item "@tokens = roman($number);"

Formats the \f(CW$number\fR in (lowercase) roman numerals, returning a list of the tokens.
.IX Xref "roman"
.ie n .IP """@tokens = Roman($number);""" 4
.el .IP "\f(CW@tokens = Roman($number);\fR" 4
.IX Item "@tokens = Roman($number);"

Formats the \f(CW$number\fR in (uppercase) roman numerals, returning a list of the tokens.
.IX Xref "Roman"
.SH "SEE ALSO"
.IX Header "SEE ALSO"

See also LaTeXML::Global,
LaTeXML::Common::Object,
LaTeXML::Common::Error,
LaTeXML::Core::Token,
LaTeXML::Core::Tokens,
LaTeXML::Core::Box,
LaTeXML::Core::List,
LaTeXML::Common::Number,
LaTeXML::Common::Float,
LaTeXML::Common::Dimension,
LaTeXML::Common::Glue,
LaTeXML::Core::MuDimension,
LaTeXML::Core::MuGlue,
LaTeXML::Core::Pair,
LaTeXML::Core::PairList,
LaTeXML::Common::Color,
LaTeXML::Core::Alignment,
LaTeXML::Common::XML,
LaTeXML::Util::Radix.
.IX Xref "See also"
.SH "AUTHOR"
.IX Header "AUTHOR"
Bruce Miller <bruce.miller@nist.gov>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Public domain software, produced as part of work done by the
United States Government & not subject to copyright in the \s-1US.\s0
